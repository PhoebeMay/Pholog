# dune build @fmt
# OCAMLPARAM: unset
$ /usr/bin/nproc > /tmp/dunee727aa.output 2> /dev/null
$ /home/phoebe/.opam/4.08.0/bin/ocamlc.opt -config > /tmp/dune4e1c5c.output
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --intf src/code_generation/genCode.mli) > _build/default/src/code_generation/.formatted/genCode.mli
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/bench/test/codeGenTest.ml) > _build/default/src/bench/test/.formatted/codeGenTest.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/code_generation/codeLoadStructure.ml) > _build/default/src/code_generation/.formatted/codeLoadStructure.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/codeLoadStructure.ml src/code_generation/.formatted/codeLoadStructure.ml)
> diff --git a/src/code_generation/codeLoadStructure.ml b/src/code_generation/.formatted/codeLoadStructure.ml
> index 35ef9f3..4795f89 100644
> --- a/src/code_generation/codeLoadStructure.ml
> +++ b/src/code_generation/.formatted/codeLoadStructure.ml
> @@ -9,12 +9,15 @@ type abstractInstruction2 =
>    | Abs_PutStructureT of structure * temp
>    | Abs_SetValue of temp
>  
> -type putArg = {build: abstractInstruction2 list; load: abstractInstruction2}
> +type putArg = {
> +  build : abstractInstruction2 list;
> +  load : abstractInstruction2;
> +}
>  
>  let rec loadFunBody seenSoFar nextFreeTemp structMapGen term =
>    match term with
> -  | TInt n -> {build= []; load= Abs_SetIntE n}
> -  | TVar var -> {build= []; load= Abs_SetVE var}
> +  | TInt n -> { build = []; load = Abs_SetIntE n }
> +  | TVar var -> { build = []; load = Abs_SetVE var }
>    | TFun (f, ts) ->
>        let nextFree = Temp !nextFreeTemp in
>        let _ = nextFreeTemp := !nextFreeTemp + 1 in
> @@ -22,18 +25,20 @@ let rec loadFunBody seenSoFar nextFreeTemp structMapGen term =
>        let build, load =
>          loadAllFunBodyAbs ts seenSoFar nextFreeTemp structMapGen
>        in
> -      { build=
> +      {
> +        build =
>            build
> -          @ [Abs_PutStructureT (getStructMapFid structMapGen fid, nextFree)]
> -          @ load
> -      ; load= Abs_SetValue nextFree }
> +          @ [ Abs_PutStructureT (getStructMapFid structMapGen fid, nextFree) ]
> +          @ load;
> +        load = Abs_SetValue nextFree;
> +      }
>  
>  and loadAllFunBodyAbs terms seenSoFar nextFreeTemp
>      (structMapGen : structMapGen) =
>    let collectBuild (xs : putArg list) =
> -    List.map ~f:(fun {build= b; load= _} -> b) (xs : putArg list)
> +    List.map ~f:(fun { build = b; load = _ } -> b) (xs : putArg list)
>    in
> -  let collectLoad xs = List.map ~f:(fun {build= _; load= l} -> l) xs in
> +  let collectLoad xs = List.map ~f:(fun { build = _; load = l } -> l) xs in
>    let res =
>      List.map ~f:(loadFunBody seenSoFar nextFreeTemp structMapGen) terms
>    in
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/bench/test/codeGenTest.ml src/bench/test/.formatted/codeGenTest.ml)
> diff --git a/src/bench/test/codeGenTest.ml b/src/bench/test/.formatted/codeGenTest.ml
> index e9c04a2..6987db9 100644
> --- a/src/bench/test/codeGenTest.ml
> +++ b/src/bench/test/.formatted/codeGenTest.ml
> @@ -42,6 +42,6 @@ let test1 () =
>    let result_sexp = sexp_of_code result in
>    assert_equal result_sexp expected_result
>  
> -let suite = "Code gen tests" >::: ["test1" >:: test1]
> +let suite = "Code gen tests" >::: [ "test1" >:: test1 ]
>  
>  let _ = run_test_tt_main suite
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/code_generation/linearise.ml) > _build/default/src/code_generation/.formatted/linearise.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --intf src/code_generation/codeStructureInArg.mli) > _build/default/src/code_generation/.formatted/codeStructureInArg.mli
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/linearise.ml src/code_generation/.formatted/linearise.ml)
> diff --git a/src/code_generation/linearise.ml b/src/code_generation/.formatted/linearise.ml
> index da5dc2f..b53fdda 100644
> --- a/src/code_generation/linearise.ml
> +++ b/src/code_generation/.formatted/linearise.ml
> @@ -34,8 +34,7 @@ let clauseIdImp =
>            let hash2 = Hash.fold_int hash arity in
>            let hash3 = Hash.fold_int hash2 pos in
>            Hash.get_hash_value hash3
> -  end
> -  : Base__.Hash_set_intf.Key
> +  end : Base__.Hash_set_intf.Key
>      with type t = clauseId )
>  
>  let putIntoArray instructions positionT =
> @@ -45,7 +44,7 @@ let putIntoArray instructions positionT =
>      match instructions with
>      | i :: is ->
>          (* print_endline ("putting in "^ show_instruction i ^" to "^(string_of_int pos)); *)
> -        codeArray.(pos) <- i ;
> +        codeArray.(pos) <- i;
>          putInstructionsInArray (pos + 1) is
>      | [] -> ()
>    in
> @@ -53,8 +52,8 @@ let putIntoArray instructions positionT =
>      match clauseCodes with
>      | [] -> currentPosition
>      | (pos, clauseInstructions) :: cs ->
> -        Hashtbl.add_exn positionT ~key:(id, pos) ~data:currentPosition ;
> -        putInstructionsInArray currentPosition clauseInstructions ;
> +        Hashtbl.add_exn positionT ~key:(id, pos) ~data:currentPosition;
> +        putInstructionsInArray currentPosition clauseInstructions;
>          putClauseCodesInArray cs id
>            (currentPosition + List.length clauseInstructions)
>    in
> @@ -66,7 +65,7 @@ let putIntoArray instructions positionT =
>          let pos2 = putClauseCodesInArray xs id currentPosition in
>          putPredCodesInArray ys pos2
>    in
> -  putPredCodesInArray instructions 0 ;
> +  putPredCodesInArray instructions 0;
>    codeArray
>  
>  let renameInstruction i positionT =
> @@ -100,7 +99,7 @@ let renameInstruction i positionT =
>  let renameArray positionT instructionArray =
>    Array.map_inplace
>      ~f:(fun i -> renameInstruction i positionT)
> -    instructionArray ;
> +    instructionArray;
>    instructionArray
>  
>  let lineariseCode is =
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/codeStructureInArg.mli src/code_generation/.formatted/codeStructureInArg.mli)
> diff --git a/src/code_generation/codeStructureInArg.mli b/src/code_generation/.formatted/codeStructureInArg.mli
> index 5ddab57..2cece16 100644
> --- a/src/code_generation/codeStructureInArg.mli
> +++ b/src/code_generation/.formatted/codeStructureInArg.mli
> @@ -3,8 +3,8 @@ open Dt
>  open Core
>  
>  val codeArgStructs :
> -     location term sexp_list
> -  -> int ref
> -  -> location Hash_set.t
> -  -> structMapGen
> -  -> instruction sexp_list
> +  location term sexp_list ->
> +  int ref ->
> +  location Hash_set.t ->
> +  structMapGen ->
> +  instruction sexp_list
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --intf src/code_generation/genFunctionTable.mli) > _build/default/src/code_generation/.formatted/genFunctionTable.mli
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/code_generation/genFunctionTable.ml) > _build/default/src/code_generation/.formatted/genFunctionTable.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/genFunctionTable.mli src/code_generation/.formatted/genFunctionTable.mli)
> diff --git a/src/code_generation/genFunctionTable.mli b/src/code_generation/.formatted/genFunctionTable.mli
> index 67c0b6a..1571e6f 100644
> --- a/src/code_generation/genFunctionTable.mli
> +++ b/src/code_generation/.formatted/genFunctionTable.mli
> @@ -3,6 +3,6 @@ open Dt
>  open Core
>  
>  val genFunctionTable :
> -     var program
> -  -> (functionId, (location clause * int) sexp_list) Base.Hashtbl.t
> -     * (location clauseBodyVal sexp_list * int)
> +  var program ->
> +  (functionId, (location clause * int) sexp_list) Base.Hashtbl.t
> +  * (location clauseBodyVal sexp_list * int)
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/genFunctionTable.ml src/code_generation/.formatted/genFunctionTable.ml)
> diff --git a/src/code_generation/genFunctionTable.ml b/src/code_generation/.formatted/genFunctionTable.ml
> index 54a9776..603dccf 100644
> --- a/src/code_generation/genFunctionTable.ml
> +++ b/src/code_generation/.formatted/genFunctionTable.ml
> @@ -21,23 +21,23 @@ let makeVariAbstract ~varMap:mapping ~envCounter ~tempCounter
>    match current with
>    | Some x -> x
>    | None ->
> -      logDebug (fun m -> m "Make abstract %a " pp_var vari) ;
> +      logDebug (fun m -> m "Make abstract %a " pp_var vari);
>        let lastUse = Hashtbl.find_exn lastuses vari in
>        let () =
>          logDebug (fun m ->
>              m "lastuse: %a, currentPosition: %a" pp_intnum lastUse pp_intnum
> -              currentPosition )
> +              currentPosition)
>        in
>        (* if ((lastUse <= 1 || currentPosition = lastUse) && not isQuery) *)
>        if false then (
>          let res = T (Temp !tempCounter) in
> -        Hashtbl.add_exn mapping ~key:vari ~data:res ;
> -        tempCounter := !tempCounter + 1 ;
> +        Hashtbl.add_exn mapping ~key:vari ~data:res;
> +        tempCounter := !tempCounter + 1;
>          res )
>        else
>          let res = E (Env !envCounter) in
> -        Hashtbl.add_exn mapping ~key:vari ~data:res ;
> -        envCounter := !envCounter + 1 ;
> +        Hashtbl.add_exn mapping ~key:vari ~data:res;
> +        envCounter := !envCounter + 1;
>          res
>  
>  (* Env(setIfNotAlready mapping vari counter) *)
> @@ -51,8 +51,8 @@ let rec makeTermAbstract ~varMap:mapping ~envCounter:counter ~useMap:lastuse
>             ~position:currentPosition ~tempCounter ~isQuery:q var)
>    | TFun (funtor, ts) ->
>        TFun
> -        ( funtor
> -        , List.map
> +        ( funtor,
> +          List.map
>              ~f:
>                (makeTermAbstract ~varMap:mapping ~envCounter:counter
>                   ~useMap:lastuse ~position:currentPosition ~tempCounter
> @@ -67,16 +67,16 @@ let rec makeMathExprAbstract ~varMap:mapping ~envCounter:counter
>        Subtract
>          ( makeMathExprAbstract ~varMap:mapping ~envCounter:counter
>              ~useMap:lastuse ~position:currentPosition ~tempCounter ~isQuery:q
> -            e1
> -        , makeMathExprAbstract ~varMap:mapping ~envCounter:counter
> +            e1,
> +          makeMathExprAbstract ~varMap:mapping ~envCounter:counter
>              ~useMap:lastuse ~position:currentPosition ~tempCounter ~isQuery:q
>              e2 )
>    | Plus (e1, e2) ->
>        Plus
>          ( makeMathExprAbstract ~varMap:mapping ~envCounter:counter
>              ~useMap:lastuse ~position:currentPosition ~tempCounter ~isQuery:q
> -            e1
> -        , makeMathExprAbstract ~varMap:mapping ~envCounter:counter
> +            e1,
> +          makeMathExprAbstract ~varMap:mapping ~envCounter:counter
>              ~useMap:lastuse ~position:currentPosition ~tempCounter ~isQuery:q
>              e2 )
>    | Base (Int n) -> Base (Int n)
> @@ -97,8 +97,8 @@ let makeBodyValAbstract ~varMap:mapping ~envCounter:counter ~useMap:lastuse
>    | CAT (Atom (name, args)) ->
>        CAT
>          (Atom
> -           ( name
> -           , List.map
> +           ( name,
> +             List.map
>                 ~f:
>                   (makeTermAbstract ~varMap:mapping ~envCounter:counter
>                      ~useMap:lastuse ~position:currentPosition ~tempCounter
> @@ -109,8 +109,8 @@ let makeBodyValAbstract ~varMap:mapping ~envCounter:counter ~useMap:lastuse
>          (IsExpr
>             ( makeVariAbstract ~varMap:mapping ~envCounter:counter
>                 ~useMap:lastuse ~position:currentPosition ~tempCounter
> -               ~isQuery:q vari
> -           , makeMathExprAbstract ~varMap:mapping ~envCounter:counter
> +               ~isQuery:q vari,
> +             makeMathExprAbstract ~varMap:mapping ~envCounter:counter
>                 ~useMap:lastuse ~position:currentPosition ~tempCounter
>                 ~isQuery:q mathexpr ))
>    | Cut -> Cut
> @@ -131,10 +131,10 @@ let rec updateLastVariableUsePositionTerm result (currentPosition : int) term =
>  let rec updateLastVariableUsePositionMathExpr result currentPosition mathexpr =
>    match mathexpr with
>    | Plus (x, y) ->
> -      updateLastVariableUsePositionMathExpr result currentPosition x ;
> +      updateLastVariableUsePositionMathExpr result currentPosition x;
>        updateLastVariableUsePositionMathExpr result currentPosition y
>    | Subtract (x, y) ->
> -      updateLastVariableUsePositionMathExpr result currentPosition x ;
> +      updateLastVariableUsePositionMathExpr result currentPosition x;
>        updateLastVariableUsePositionMathExpr result currentPosition y
>    | Base (Int _) -> ()
>    | Base (Var var) ->
> @@ -144,13 +144,13 @@ let rec updateLastVariableUsePositionMathExpr result currentPosition mathexpr =
>  (* TODO CAN I COMPILE 1 IS 1 *)
>  
>  let rec updateLastVariableUsePositionClauseBodyVal result currentPosition bv =
> -  logDebug (fun m -> m "updateLastVariableUsePositionClauseBodyVal") ;
> +  logDebug (fun m -> m "updateLastVariableUsePositionClauseBodyVal");
>    match bv with
>    | CAT (Atom (name, args)) ->
>        List.iter args
>          ~f:(updateLastVariableUsePositionTerm result currentPosition)
>    | CAR (IsExpr (vari, mathexpr)) ->
> -      updateLastVariableUsePositionMathExpr result currentPosition mathexpr ;
> +      updateLastVariableUsePositionMathExpr result currentPosition mathexpr;
>        Hashtbl.change result vari ~f:(fun _ -> Some currentPosition)
>    | Cut -> ()
>    | Fail -> ()
> @@ -162,8 +162,8 @@ let rec getTermsLastUse result counter x =
>    match x with
>    | [] -> ()
>    | t :: ts ->
> -      logDebug (fun m -> m "hi") ;
> -      updateLastVariableUsePositionClauseBodyVal result counter t ;
> +      logDebug (fun m -> m "hi");
> +      updateLastVariableUsePositionClauseBodyVal result counter t;
>        getTermsLastUse result (counter + 1) ts
>  
>  let getPositionLastVarUse (Clause (head, terms)) =
> @@ -178,7 +178,7 @@ let getPositionLastVarUse (Clause (head, terms)) =
>           updateLastVariableUsePositionClauseBodyVal result counter t;
>           applyToTerms (counter + 1) ts *)
>    in
> -  getTermsLastUse result 1 terms ;
> +  getTermsLastUse result 1 terms;
>    result
>  
>  let rec genAbstCBVList ~varMap:mapping ~envCounter:envVars ~useMap:lastuse
> @@ -206,9 +206,9 @@ let makeClauseAbstract c =
>          getPositionLastVarUse (Clause (Atom (name, args), terms))
>        in
>        let () =
> -        logDebug (fun m -> m "last use is") ;
> +        logDebug (fun m -> m "last use is");
>          Hashtbl.iteri lastuse ~f:(fun ~key ~data:value ->
> -            logDebug (fun m -> m "(%a,%a)\n" pp_var key pp_intnum value) )
> +            logDebug (fun m -> m "(%a,%a)\n" pp_var key pp_intnum value))
>        in
>        let abstHead =
>          List.map
> @@ -229,7 +229,7 @@ let makeClauseAbstract c =
>        let ansClause = Clause (Atom (name, abstHead), abstTail) in
>        let () =
>          logDebug (fun m ->
> -            m "Abstract clause is %a" (pp_clause pp_location) ansClause )
> +            m "Abstract clause is %a" (pp_clause pp_location) ansClause)
>        in
>        (ansClause, !envVars)
>    | _ -> raise Oops
> @@ -244,7 +244,7 @@ let genFunctionTable (Program (Sentence prog, Resolvant goals)) =
>      | (Clause (Atom (name, args), body), n) :: cs ->
>          Hashtbl.add_multi hashT
>            ~key:(AbstractF (name, List.length args))
> -          ~data:(Clause (Atom (name, args), body), n) ;
> +          ~data:(Clause (Atom (name, args), body), n);
>          genFunctionTableH cs hashT
>    in
>    let table =
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/code_generation/codeStructureInArg.ml) > _build/default/src/code_generation/.formatted/codeStructureInArg.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/codeStructureInArg.ml src/code_generation/.formatted/codeStructureInArg.ml)
> diff --git a/src/code_generation/codeStructureInArg.ml b/src/code_generation/.formatted/codeStructureInArg.ml
> index 7f32bda..bb60d73 100644
> --- a/src/code_generation/codeStructureInArg.ml
> +++ b/src/code_generation/.formatted/codeStructureInArg.ml
> @@ -10,7 +10,10 @@ type abstractInstruction1 =
>    | Abs_GetStructureT of structure * temp
>    | Abs_StructGetInt of int
>  
> -type getArg = {unify: abstractInstruction1; body: abstractInstruction1 list}
> +type getArg = {
> +  unify : abstractInstruction1;
> +  body : abstractInstruction1 list;
> +}
>  
>  let getStructMapInt (structMapGen : structMapGen) str =
>    let x = Hashtbl.find structMapGen.mapping str in
> @@ -18,8 +21,8 @@ let getStructMapInt (structMapGen : structMapGen) str =
>    | Some n -> n
>    | None ->
>        let next = structMapGen.nextFree in
> -      Hashtbl.add_exn structMapGen.mapping ~key:str ~data:next ;
> -      structMapGen.nextFree <- next + 1 ;
> +      Hashtbl.add_exn structMapGen.mapping ~key:str ~data:next;
> +      structMapGen.nextFree <- next + 1;
>        next
>  
>  let rec codeArgStructAbs nextFreeTemp (term : location term)
> @@ -27,18 +30,20 @@ let rec codeArgStructAbs nextFreeTemp (term : location term)
>    match term with
>    | TVar var ->
>        ( (* logDebug (fun m -> m "codeArgStruct %a" (pp_term pp_env) term ); *)
> -        {unify= Abs_UnifyE var; body= []}
> +        { unify = Abs_UnifyE var; body = [] }
>          : getArg )
>    | TFun (name, ts) ->
>        let arity = List.length ts in
>        let nextFree = Temp !nextFreeTemp in
>        let _ = nextFreeTemp := !nextFreeTemp + 1 in
> -      { unify= Abs_StructGetVariableT nextFree
> -      ; body=
> +      {
> +        unify = Abs_StructGetVariableT nextFree;
> +        body =
>            Abs_GetStructureT
>              ((getStructMapInt structMapGen name, arity), nextFree)
> -          :: codeArgStructsAbs ts nextFreeTemp structMapGen }
> -  | TInt n -> ({unify= Abs_StructGetInt n; body= []} : getArg)
> +          :: codeArgStructsAbs ts nextFreeTemp structMapGen;
> +      }
> +  | TInt n -> ({ unify = Abs_StructGetInt n; body = [] } : getArg)
>  
>  and codeArgStructsAbs terms (nextFreeTemp : int ref) structMapGen =
>    let rec codeArgStructsH terms (nextFreeTemp : int ref) structMapGen =
> @@ -52,10 +57,10 @@ and codeArgStructsAbs terms (nextFreeTemp : int ref) structMapGen =
>    in
>    let collect results =
>      let collectHead results =
> -      List.map ~f:(fun {unify= h; body= _} -> h) results
> +      List.map ~f:(fun { unify = h; body = _ } -> h) results
>      in
>      let collectTail results =
> -      List.map ~f:(fun {unify= _; body= t} -> t) results
> +      List.map ~f:(fun { unify = _; body = t } -> t) results
>      in
>      let head = collectHead results in
>      let tail = List.concat (collectTail results) in
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --intf src/code_generation/codeLoadStructure.mli) > _build/default/src/code_generation/.formatted/codeLoadStructure.mli
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/codeLoadStructure.mli src/code_generation/.formatted/codeLoadStructure.mli)
> diff --git a/src/code_generation/codeLoadStructure.mli b/src/code_generation/.formatted/codeLoadStructure.mli
> index ce1469f..794a317 100644
> --- a/src/code_generation/codeLoadStructure.mli
> +++ b/src/code_generation/.formatted/codeLoadStructure.mli
> @@ -3,8 +3,8 @@ open Dt
>  open Core
>  
>  val loadAllFunBody :
> -     location term sexp_list
> -  -> location Hash_set.t
> -  -> int ref
> -  -> structMapGen
> -  -> instruction list * instruction list
> +  location term sexp_list ->
> +  location Hash_set.t ->
> +  int ref ->
> +  structMapGen ->
> +  instruction list * instruction list
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --intf src/code_generation/linearise.mli) > _build/default/src/code_generation/.formatted/linearise.mli
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/code_generation/genCode.ml) > _build/default/src/code_generation/.formatted/genCode.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/linearise.mli src/code_generation/.formatted/linearise.mli)
> diff --git a/src/code_generation/linearise.mli b/src/code_generation/.formatted/linearise.mli
> index 83429ef..ca8d0e1 100644
> --- a/src/code_generation/linearise.mli
> +++ b/src/code_generation/.formatted/linearise.mli
> @@ -2,8 +2,9 @@ open Core
>  open Dt
>  
>  val lineariseCode :
> -     (functionId * (int * instruction sexp_list) sexp_list) sexp_list
> -  -> instruction sexp_array
> +  (functionId * (int * instruction sexp_list) sexp_list) sexp_list ->
> +  instruction sexp_array
> +
>  (*
>  val lineariseCode : (functionId * (int * instruction sexp_list) sexp_list) sexp_list ->
>  (functionId * int, int) Base.Hashtbl.t -> instruction sexp_array *)
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/genCode.ml src/code_generation/.formatted/genCode.ml)
> diff --git a/src/code_generation/genCode.ml b/src/code_generation/.formatted/genCode.ml
> index a1f0a96..e206e58 100644
> --- a/src/code_generation/genCode.ml
> +++ b/src/code_generation/.formatted/genCode.ml
> @@ -24,10 +24,10 @@ type functTlist = (functionId * functTval) list [@@deriving sexp]
>  let codeArgTerm (arg : location term) argnum seenSoFar nextFreeTemp
>      structMapGen =
>    match arg with
> -  | TInt n -> [GetInt (Arg argnum, n)]
> +  | TInt n -> [ GetInt (Arg argnum, n) ]
>    | TVar var ->
> -      if seen var seenSoFar then [GetValue (var, Arg argnum)]
> -      else [GetVariable (var, Arg argnum)]
> +      if seen var seenSoFar then [ GetValue (var, Arg argnum) ]
> +      else [ GetVariable (var, Arg argnum) ]
>    | TFun (funct, ts) ->
>        (*GET TS*)
>        GetStructureA
> @@ -46,10 +46,10 @@ let rec codeArgs ars counter seenSoFar nextFreeTemp structMapGen =
>  
>  let loadArg argnum seenSoFar nextFreeTemp structMapGen (term : location term) =
>    match term with
> -  | TInt n -> [PutIntA (Arg argnum, n)]
> +  | TInt n -> [ PutIntA (Arg argnum, n) ]
>    | TVar var ->
> -      if seen var seenSoFar then [PutValue (var, Arg argnum)]
> -      else [PutVariable (var, Arg argnum)]
> +      if seen var seenSoFar then [ PutValue (var, Arg argnum) ]
> +      else [ PutVariable (var, Arg argnum) ]
>    | TFun (funct, ts) ->
>        let build, load =
>          loadAllFunBody ts seenSoFar nextFreeTemp structMapGen
> @@ -67,8 +67,8 @@ let loadArgs (terms : location term list) (seenSoFar : location Hash_set.t)
>      List.concat
>        (List.map
>           ~f:(fun t ->
> -           argnum := !argnum + 1 ;
> -           loadArg (!argnum - 1) seenSoFar nextFreeTemp structMapGen t )
> +           argnum := !argnum + 1;
> +           loadArg (!argnum - 1) seenSoFar nextFreeTemp structMapGen t)
>           terms)
>    in
>    ans
> @@ -76,15 +76,15 @@ let loadArgs (terms : location term list) (seenSoFar : location Hash_set.t)
>  let rec codeArith seenSoFar codeArithT (item : location mathExpr) =
>    match item with
>    | Plus (exp1, Base (Int n)) ->
> -      codeArith seenSoFar codeArithT exp1 @ [AddI (codeArithT, n)]
> +      codeArith seenSoFar codeArithT exp1 @ [ AddI (codeArithT, n) ]
>    | Plus (exp1, Base (Var v)) ->
> -      codeArith seenSoFar codeArithT exp1 @ [Add (codeArithT, v)]
> +      codeArith seenSoFar codeArithT exp1 @ [ Add (codeArithT, v) ]
>    | Subtract (exp1, Base (Int n)) ->
> -      codeArith seenSoFar codeArithT exp1 @ [SubI (codeArithT, n)]
> +      codeArith seenSoFar codeArithT exp1 @ [ SubI (codeArithT, n) ]
>    | Subtract (exp1, Base (Var v)) ->
> -      codeArith seenSoFar codeArithT exp1 @ [Sub (codeArithT, v)]
> -  | Base (Int n) -> [PutIntT (codeArithT, n)]
> -  | Base (Var v) -> [InitAcc (codeArithT, v)]
> +      codeArith seenSoFar codeArithT exp1 @ [ Sub (codeArithT, v) ]
> +  | Base (Int n) -> [ PutIntT (codeArithT, n) ]
> +  | Base (Var v) -> [ InitAcc (codeArithT, v) ]
>    | _ -> raise (Err "Parse tree malformed, addition left assoc")
>  
>  let codeBodyVal (seenSoFar : location Hash_set.t) nextFreeTemp structMapGen
> @@ -92,15 +92,15 @@ let codeBodyVal (seenSoFar : location Hash_set.t) nextFreeTemp structMapGen
>    match clauseBodyItem with
>    | CAT (Atom (pred, terms)) ->
>        loadArgs terms seenSoFar nextFreeTemp structMapGen
> -      @ [Call (AbstractF (pred, List.length terms))]
> -  | Cut -> [RmCps]
> -  | Fail -> [Backtrack]
> +      @ [ Call (AbstractF (pred, List.length terms)) ]
> +  | Cut -> [ RmCps ]
> +  | Fail -> [ Backtrack ]
>    | CAR (IsExpr (var, body)) ->
>        let codeArithT = Temp !nextFreeTemp in
>        let () = nextFreeTemp := !nextFreeTemp + 1 in
>        let bodyCode = codeArith seenSoFar codeArithT body in
>        let () = Hash_set.add seenSoFar var in
> -      bodyCode @ [Is (var, codeArithT)]
> +      bodyCode @ [ Is (var, codeArithT) ]
>  
>  let codeBody (bodyVals : location clauseBodyVal list)
>      (seenSoFar : location Hash_set.t) nextFreeTemp structMapGen =
> @@ -114,7 +114,7 @@ let codeBody (bodyVals : location clauseBodyVal list)
>  let rec firstLast xs res =
>    match xs with
>    | [] -> raise Oops
> -  | [x] -> (x, List.rev res)
> +  | [ x ] -> (x, List.rev res)
>    | y :: ys -> firstLast ys (y :: res)
>  
>  let rec getMaxTempTerm result term =
> @@ -129,10 +129,10 @@ let getMaxTempAtom (Atom (_, args)) result =
>  let rec getMaxTempMathExpr result mathExpr =
>    match mathExpr with
>    | Plus (x, y) ->
> -      getMaxTempMathExpr result x ;
> +      getMaxTempMathExpr result x;
>        getMaxTempMathExpr result y
>    | Subtract (x, y) ->
> -      getMaxTempMathExpr result x ;
> +      getMaxTempMathExpr result x;
>        getMaxTempMathExpr result y
>    | Base (Int _) -> ()
>    | Base (Var (T (Temp pos))) -> if pos > !result then result := pos else ()
> @@ -144,7 +144,7 @@ let getMaxTempCBV result cbv =
>    | Fail -> ()
>    | CAT a -> getMaxTempAtom a result
>    | CAR (IsExpr (vari, mathexpr)) -> (
> -      getMaxTempMathExpr result mathexpr ;
> +      getMaxTempMathExpr result mathexpr;
>        match vari with
>        | T (Temp pos) -> if pos > !result then result := pos else ()
>        | _ -> () )
> @@ -153,39 +153,40 @@ let getMaxTempCBV result cbv =
>  
>  let rec getMaxTempClause (Clause (head, tail)) =
>    let result = ref 0 in
> -  getMaxTempAtom head result ;
> -  List.iter ~f:(getMaxTempCBV result) tail ;
> +  getMaxTempAtom head result;
> +  List.iter ~f:(getMaxTempCBV result) tail;
>    !result
>  
>  and addTempClears defined instructions =
>    match instructions with
>    | [] -> ([] : instruction list)
>    | i :: is -> (
> -    match i with
> -    | GetVariable (T t, _) ->
> -        Hash_set.add defined (T t) ;
> -        i :: addTempClears defined is
> -    | StructGetVariable (T t) ->
> -        if not (Hash_set.find defined ~f:(fun x -> x = T t) = None) then (
> -          logDebug (fun m -> m "IT WAS DEFINED") ;
> +      match i with
> +      | GetVariable (T t, _) ->
> +          Hash_set.add defined (T t);
>            i :: addTempClears defined is
> -          (* else (  Hash_set.add defined (T(t)); (ClearTemp t)::i::(addTempClears defined is)) *) )
> -        else (
> -          Hash_set.add defined (T t) ;
> -          i :: addTempClears defined is )
> -    | InitAcc (_, T t) ->
> -        if not (Hash_set.find defined ~f:(fun x -> x = T t) = None) then
> -          i :: addTempClears defined is
> -        else (
> -          Hash_set.add defined (T t) ;
> -          ClearTemp t :: i :: addTempClears defined is )
> -    | Is (T t, _) ->
> -        if not (Hash_set.find defined ~f:(fun x -> x = T t) = None) then
> -          i :: addTempClears defined is
> -        else (
> -          Hash_set.add defined (T t) ;
> -          ClearTemp t :: i :: addTempClears defined is )
> -    | _ -> i :: addTempClears defined is )
> +      | StructGetVariable (T t) ->
> +          if not (Hash_set.find defined ~f:(fun x -> x = T t) = None) then (
> +            logDebug (fun m -> m "IT WAS DEFINED");
> +            i :: addTempClears defined is
> +            (* else (  Hash_set.add defined (T(t)); (ClearTemp t)::i::(addTempClears defined is)) *)
> +            )
> +          else (
> +            Hash_set.add defined (T t);
> +            i :: addTempClears defined is )
> +      | InitAcc (_, T t) ->
> +          if not (Hash_set.find defined ~f:(fun x -> x = T t) = None) then
> +            i :: addTempClears defined is
> +          else (
> +            Hash_set.add defined (T t);
> +            ClearTemp t :: i :: addTempClears defined is )
> +      | Is (T t, _) ->
> +          if not (Hash_set.find defined ~f:(fun x -> x = T t) = None) then
> +            i :: addTempClears defined is
> +          else (
> +            Hash_set.add defined (T t);
> +            ClearTemp t :: i :: addTempClears defined is )
> +      | _ -> i :: addTempClears defined is )
>  
>  let codeClause ((clause, n) : location clause * int) arrLens structMapGen =
>    let seen = Base.Hash_set.create locationImp in
> @@ -201,31 +202,30 @@ let codeClause ((clause, n) : location clause * int) arrLens structMapGen =
>      load @ call
>    in
>    let result =
> -    match (clause, n) with Clause (Atom (_name, args), tail), n ->
> -      let bodycode =
> -        codeInsideClause args tail
> -        (* in let (t,hs) = firstLast bodycode []
> +    match (clause, n) with
> +    | Clause (Atom (_name, args), tail), n ->
> +        let bodycode =
> +          codeInsideClause args tail
> +          (* in let (t,hs) = firstLast bodycode []
>             in match t with
>             | Call(x) -> Allocate n :: hs @  [DeallocateBeforeLastCall] @ [CallAfterDealloc(x)]
>             | _ -> Allocate n :: hs @ [t] @ [Deallocate] *)
> -      in
> -      if List.length bodycode > 0 then
> -        let t, hs = firstLast bodycode [] in
> -        match t
> -        with
> -        (* TODO UNDO *)
> -        (* | Call(x) -> Allocate n :: hs @  [DeallocateBeforeLastCall] @ [CallAfterDealloc(x)] *)
> -        | _
> -        -> (Allocate n :: hs) @ [t] @ [Deallocate]
> -      else [Allocate n; Deallocate]
> +        in
> +        if List.length bodycode > 0 then
> +          let t, hs = firstLast bodycode [] in
> +          match t with
> +          (* TODO UNDO *)
> +          (* | Call(x) -> Allocate n :: hs @  [DeallocateBeforeLastCall] @ [CallAfterDealloc(x)] *)
> +          | _ -> (Allocate n :: hs) @ [ t ] @ [ Deallocate ]
> +        else [ Allocate n; Deallocate ]
>    in
>    addTempClears (Hash_set.create locationImp ()) result
>  
>  let rec codeNotFirstClauses id clauses counter arrLens structMapGen =
>    match clauses with
>    | [] -> raise Oops
> -  | [c] ->
> -      let r = [(counter, TrustMe :: codeClause c arrLens structMapGen)] in
> +  | [ c ] ->
> +      let r = [ (counter, TrustMe :: codeClause c arrLens structMapGen) ] in
>        r
>    | c :: cs ->
>        let head =
> @@ -238,7 +238,7 @@ let rec codeNotFirstClauses id clauses counter arrLens structMapGen =
>  let codeFirstClause id clauses arrLens structMapGen =
>    match clauses with
>    | [] -> raise Oops
> -  | [c] -> [(0, codeClause c arrLens structMapGen)]
> +  | [ c ] -> [ (0, codeClause c arrLens structMapGen) ]
>    | c :: cs ->
>        let head =
>          TryMeElse (AbstractC (id, 1)) :: codeClause c arrLens structMapGen
> @@ -263,20 +263,23 @@ let codeAllClauses
>  let codeQuery query arrLens structMapGen =
>    let seen = Base.Hash_set.create locationImp in
>    let nextFreeTemp = ref 0 in
> -  match query with body, n ->
> -    let res =
> -      [ ( AbstractF ("query", 0)
> -        , [ ( 0
> -            , (Allocate n :: codeBody body seen nextFreeTemp structMapGen)
> -              @ [Finish] ) ] ) ]
> -    in
> -    arrLens.maxTemp <- max arrLens.maxTemp !nextFreeTemp ;
> -    res
> +  match query with
> +  | body, n ->
> +      let res =
> +        [ ( AbstractF ("query", 0),
> +            [ ( 0,
> +                (Allocate n :: codeBody body seen nextFreeTemp structMapGen)
> +                @ [ Finish ] )
> +            ] )
> +        ]
> +      in
> +      arrLens.maxTemp <- max arrLens.maxTemp !nextFreeTemp;
> +      res
>  
>  let genCode parseTree =
>    let functionTable, query = genFunctionTable parseTree in
> -  let arrLens = {maxArg= 0; maxTemp= 0} in
> -  let structMapGen = {mapping= Hashtbl.create strKeyImp; nextFree= 0} in
> +  let arrLens = { maxArg = 0; maxTemp = 0 } in
> +  let structMapGen = { mapping = Hashtbl.create strKeyImp; nextFree = 0 } in
>    let querycode = codeQuery query arrLens structMapGen in
>    let bodycode = codeAllClauses functionTable arrLens structMapGen in
>    let code = querycode @ bodycode in
> @@ -285,5 +288,5 @@ let genCode parseTree =
>      (* in (code, arrLens, lookupmap) *)
>    in
>    let flatcode = lineariseCode code in
> -  let instr = {code= flatcode; nums= arrLens; structMap= lookupmap} in
> +  let instr = { code = flatcode; nums = arrLens; structMap = lookupmap } in
>    instr
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/code_generation/test/codeGenTest.ml) > _build/default/src/code_generation/test/.formatted/codeGenTest.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/code_generation/test/codeGenTest.ml src/code_generation/test/.formatted/codeGenTest.ml)
> diff --git a/src/code_generation/test/codeGenTest.ml b/src/code_generation/test/.formatted/codeGenTest.ml
> index e9c04a2..6987db9 100644
> --- a/src/code_generation/test/codeGenTest.ml
> +++ b/src/code_generation/test/.formatted/codeGenTest.ml
> @@ -42,6 +42,6 @@ let test1 () =
>    let result_sexp = sexp_of_code result in
>    assert_equal result_sexp expected_result
>  
> -let suite = "Code gen tests" >::: ["test1" >:: test1]
> +let suite = "Code gen tests" >::: [ "test1" >:: test1 ]
>  
>  let _ = run_test_tt_main suite
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/execute/stackImplementation.ml) > _build/default/src/execute/.formatted/stackImplementation.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/execute/stackImplementation.ml src/execute/.formatted/stackImplementation.ml)
> diff --git a/src/execute/stackImplementation.ml b/src/execute/.formatted/stackImplementation.ml
> index c0c3059..cd83504 100644
> --- a/src/execute/stackImplementation.ml
> +++ b/src/execute/.formatted/stackImplementation.ml
> @@ -1,10 +1,10 @@
>  open Core
>  
> -type 'a node = {mutable prev: 'a node option; value: 'a} [@@deriving show]
> +type 'a node = { mutable prev : 'a node option; value : 'a } [@@deriving show]
>  
>  let createEmpty = None
>  
> -let createNew v ~prev:p = Some {prev= p; value= v}
> +let createNew v ~prev:p = Some { prev = p; value = v }
>  
>  let rec getPredsh node =
>    match node with None -> [] | Some n -> n :: getPredsh n.prev
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/execute/runtimeDataStructures.ml) > _build/default/src/execute/.formatted/runtimeDataStructures.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/datatypes/dt.ml) > _build/default/src/datatypes/.formatted/dt.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/datatypes/dt.ml src/datatypes/.formatted/dt.ml)
> diff --git a/src/datatypes/dt.ml b/src/datatypes/.formatted/dt.ml
> index 7084134..6792ef0 100644
> --- a/src/datatypes/dt.ml
> +++ b/src/datatypes/.formatted/dt.ml
> @@ -33,16 +33,17 @@ let intImp =
>      let sexp_of_t = sexp_of_int
>  
>      let hash x = x
> -  end
> -  : Base__.Hash_set_intf.Key
> +  end : Base__.Hash_set_intf.Key
>      with type t = int )
>  
>  type structureLookup = string Base.Hashtbl.M(Int).t [@@deriving sexp]
>  
>  type varLookup = var Base.Hashtbl.M(Int).t [@@deriving sexp]
>  
> -type structMapGen =
> -  {mapping: (string, int) Base.Hashtbl.t; mutable nextFree: int}
> +type structMapGen = {
> +  mapping : (string, int) Base.Hashtbl.t;
> +  mutable nextFree : int;
> +}
>  
>  type functionId = AbstractF of (string * int) | PositionF of int
>  [@@deriving sexp, show]
> @@ -60,8 +61,7 @@ let envImp =
>      let sexp_of_t = sexp_of_env
>  
>      let hash (Env x) = x
> -  end
> -  : Base__.Hash_set_intf.Key
> +  end : Base__.Hash_set_intf.Key
>      with type t = env )
>  
>  let locationImp =
> @@ -73,8 +73,7 @@ let locationImp =
>      let sexp_of_t = sexp_of_location
>  
>      let hash x = match x with E (Env n) -> n * 2 | T (Temp n) -> (n * 2) + 1
> -  end
> -  : Base__.Hash_set_intf.Key
> +  end : Base__.Hash_set_intf.Key
>      with type t = location )
>  
>  let functionTKeyImp =
> @@ -92,8 +91,7 @@ let functionTKeyImp =
>            let hash = Hash.create ~seed:(String.hash name) () in
>            let hash2 = Hash.fold_int hash arity in
>            Hash.get_hash_value hash2
> -  end
> -  : Base__.Hashtbl_intf.Key
> +  end : Base__.Hashtbl_intf.Key
>      with type t = functionId )
>  
>  let strKeyImp =
> @@ -105,8 +103,7 @@ let strKeyImp =
>      let sexp_of_t = sexp_of_string
>  
>      let hash x = String.hash x
> -  end
> -  : Base__.Hashtbl_intf.Key
> +  end : Base__.Hashtbl_intf.Key
>      with type t = string )
>  
>  type strInt = string * int [@@deriving show, sexp]
> @@ -123,8 +120,7 @@ let strIntKeyImp =
>        let hash = Hash.create ~seed:(String.hash x) () in
>        let hash2 = Hash.fold_int hash y in
>        Hash.get_hash_value hash2
> -  end
> -  : Base__.Hashtbl_intf.Key
> +  end : Base__.Hashtbl_intf.Key
>      with type t = string * int )
>  
>  (*
> @@ -182,10 +178,14 @@ type instruction =
>  
>  type inner = clauseAndNum list [@@deriving show, sexp]
>  
> -type arrLens = {mutable maxArg: int; mutable maxTemp: int} [@@deriving sexp]
> +type arrLens = { mutable maxArg : int; mutable maxTemp : int }
> +[@@deriving sexp]
>  
> -type writtenInstr =
> -  {nums: arrLens; code: instruction sexp_array; structMap: structureLookup}
> +type writtenInstr = {
> +  nums : arrLens;
> +  code : instruction sexp_array;
> +  structMap : structureLookup;
> +}
>  [@@deriving sexp]
>  
>  type heapValue =
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/execute/runProgram.ml) > _build/default/src/execute/.formatted/runProgram.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/execute/runtimeDataStructures.ml src/execute/.formatted/runtimeDataStructures.ml)
> diff --git a/src/execute/runtimeDataStructures.ml b/src/execute/.formatted/runtimeDataStructures.ml
> index d549d48..343fa34 100644
> --- a/src/execute/runtimeDataStructures.ml
> +++ b/src/execute/.formatted/runtimeDataStructures.ml
> @@ -15,38 +15,41 @@ type varr = variable array [@@deriving show]
>  
>  type trail = trailVal node option [@@deriving show]
>  
> -type choicePoint =
> -  { mutable nextOptionPointer: int
> -  ; stack: stackVal
> -  ; arguments: variable array
> -  ; returnAddr: int
> -  ; returnCps: choicePoint node option
> -  ; returnTrailPoint: trailVal node option }
> +type choicePoint = {
> +  mutable nextOptionPointer : int;
> +  stack : stackVal;
> +  arguments : variable array;
> +  returnAddr : int;
> +  returnCps : choicePoint node option;
> +  returnTrailPoint : trailVal node option;
> +}
>  [@@deriving show]
>  
>  and choicePointStack = choicePoint node option [@@deriving show]
>  
> -and environment =
> -  { vars: variable array
> -  ; mutable returnAddress: int
> -  ; callerCps: choicePointStack
> -  ; callerTrailpoint: trailVal node option }
> +and environment = {
> +  vars : variable array;
> +  mutable returnAddress : int;
> +  callerCps : choicePointStack;
> +  callerTrailpoint : trailVal node option;
> +}
>  [@@deriving show]
>  
>  and stackVal = environment node option [@@deriving show]
>  
> -type compState =
> -  { mutable currentStr: heapValue sexp_array * intnum
> -  ; mutable cp: int
> -  ; mutable returnAddress: int
> -  ; mutable returnCps: choicePoint node option
> -  ; mutable returnTrailPoint: trailVal node option
> -  ; mutable arguments: variable sexp_array
> -  ; mutable temps: variable sexp_array
> -  ; mutable choicePoints: choicePointStack
> -  ; mutable envStack: stackVal
> -  ; mutable trail: trailVal node option
> -  ; mutable infinal: bool }
> +type compState = {
> +  mutable currentStr : heapValue sexp_array * intnum;
> +  mutable cp : int;
> +  mutable returnAddress : int;
> +  mutable returnCps : choicePoint node option;
> +  mutable returnTrailPoint : trailVal node option;
> +  mutable arguments : variable sexp_array;
> +  mutable temps : variable sexp_array;
> +  mutable choicePoints : choicePointStack;
> +  mutable envStack : stackVal;
> +  mutable trail : trailVal node option;
> +  mutable infinal : bool;
> +}
>  
>  module type DriverTyp = sig
>    val execute : compState -> environment option
> @@ -54,20 +57,20 @@ end
>  
>  module type InstructionFunctionsTyp = sig
>    val performArith :
> -       compState
> -    -> location
> -    -> intnum
> -    -> environment node
> -    -> (intnum -> intnum -> intnum)
> -    -> environment option
> +    compState ->
> +    location ->
> +    intnum ->
> +    environment node ->
> +    (intnum -> intnum -> intnum) ->
> +    environment option
>  
>    val evalIs :
> -       variable
> -    -> intnum
> -    -> variable sexp_array
> -    -> intnum
> -    -> compState
> -    -> environment option
> +    variable ->
> +    intnum ->
> +    variable sexp_array ->
> +    intnum ->
> +    compState ->
> +    environment option
>  
>    val getinta : variable -> int -> compState -> environment option
>  
> @@ -75,12 +78,12 @@ module type InstructionFunctionsTyp = sig
>      int -> int -> variable array -> int -> compState -> environment option
>  
>    val putStructure :
> -       intnum
> -    -> intnum
> -    -> variable sexp_array
> -    -> intnum
> -    -> compState
> -    -> environment option
> +    intnum ->
> +    intnum ->
> +    variable sexp_array ->
> +    intnum ->
> +    compState ->
> +    environment option
>  
>    val unifyInFromHeap :
>      variable sexp_array -> intnum -> compState -> environment option
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/execute/runProgram.ml src/execute/.formatted/runProgram.ml)
> diff --git a/src/execute/runProgram.ml b/src/execute/.formatted/runProgram.ml
> index f4d9436..11ec8ea 100644
> --- a/src/execute/runProgram.ml
> +++ b/src/execute/.formatted/runProgram.ml
> @@ -4,14 +4,15 @@ open Execute
>  open Initialise
>  open RuntimeDataStructures
>  
> -let runProgram ({nums= arrLens; code= instructions; structMap} : writtenInstr)
> -    : 'a option =
> +let runProgram
> +    ({ nums = arrLens; code = instructions; structMap } : writtenInstr) :
> +    'a option =
>    (* logError (fun m -> m " execute isntructions "); *)
>    (* let returnAddress = ref (-1) *)
> -  
> +
>    (* let resCount = ref 1 *)
>    (* in let itercount = ref 0 *)
> -  
> +
>    (* in  *)
>    try
>      let is = getInitialState arrLens in
> @@ -23,6 +24,7 @@ let rec extractVariables vs counter =
>    if counter >= Array.length vs then []
>    else vs.(counter) :: extractVariables vs (counter + 1)
>  
> -let format {vars= vs; returnAddress= _; callerCps= _; callerTrailpoint= _} =
> +let format
> +    { vars = vs; returnAddress = _; callerCps = _; callerTrailpoint = _ } =
>    let vList = extractVariables vs 0 in
>    vList
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/execute/initialise.ml) > _build/default/src/execute/.formatted/initialise.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/execute/instructionImplementationsFunctor.ml) > _build/default/src/execute/.formatted/instructionImplementationsFunctor.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/execute/unification.ml) > _build/default/src/execute/.formatted/unification.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/execute/initialise.ml src/execute/.formatted/initialise.ml)
> diff --git a/src/execute/initialise.ml b/src/execute/.formatted/initialise.ml
> index 8370a0c..7dbd576 100644
> --- a/src/execute/initialise.ml
> +++ b/src/execute/.formatted/initialise.ml
> @@ -15,16 +15,18 @@ let getInitialState arrLens =
>      logDebug (fun m -> m "temps length is %a" pp_intnum arrLens.maxTemp)
>    in
>    let initialState =
> -    { currentStr
> -    ; cp
> -    ; returnAddress
> -    ; returnCps
> -    ; returnTrailPoint
> -    ; arguments
> -    ; temps
> -    ; choicePoints= None
> -    ; envStack= None
> -    ; trail= StackImplementation.createNew Label ~prev:None
> -    ; infinal= true }
> +    {
> +      currentStr;
> +      cp;
> +      returnAddress;
> +      returnCps;
> +      returnTrailPoint;
> +      arguments;
> +      temps;
> +      choicePoints = None;
> +      envStack = None;
> +      trail = StackImplementation.createNew Label ~prev:None;
> +      infinal = true;
> +    }
>    in
>    initialState
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/execute/instructionImplementationsFunctor.ml src/execute/.formatted/instructionImplementationsFunctor.ml)
> diff --git a/src/execute/instructionImplementationsFunctor.ml b/src/execute/.formatted/instructionImplementationsFunctor.ml
> index e3a0af1..a2551d6 100644
> --- a/src/execute/instructionImplementationsFunctor.ml
> +++ b/src/execute/.formatted/instructionImplementationsFunctor.ml
> @@ -18,15 +18,15 @@ struct
>      in
>      match (oldVal, envVal) with
>      | TempInt x, HeapPointer (B hp) -> (
> -      match !hp with
> -      | Int y ->
> -          compState.temps.(accu) <- TempInt (arithfun x y) ;
> -          compState.cp <- compState.cp + 1 ;
> -          D.execute compState
> -      | _ -> raise (Err "Add non-int var") )
> +        match !hp with
> +        | Int y ->
> +            compState.temps.(accu) <- TempInt (arithfun x y);
> +            compState.cp <- compState.cp + 1;
> +            D.execute compState
> +        | _ -> raise (Err "Add non-int var") )
>      | TempInt x, HeapPointer (Int y) ->
> -        compState.temps.(accu) <- TempInt (arithfun x y) ;
> -        compState.cp <- compState.cp + 1 ;
> +        compState.temps.(accu) <- TempInt (arithfun x y);
> +        compState.cp <- compState.cp + 1;
>          D.execute compState
>      | _ -> raise (Err "opsoo")
>  
> @@ -39,7 +39,7 @@ struct
>          | TempInt n ->
>              let newEnv = HeapPointer (Int n) in
>              let () = place.(numset) <- newEnv in
> -            compState.cp <- compState.cp + 1 ;
> +            compState.cp <- compState.cp + 1;
>              D.execute compState
>          | y -> raise (Err (show_variable y)) )
>      | other -> raise (Err (show_variable other))
> @@ -48,25 +48,25 @@ struct
>      (* logDebug (fun m -> m "eval is heap, x is %a " pp_heapValue x); *)
>      match x with
>      | B hp -> (
> -      match !hp with
> -      | UnboundVar -> (
> -          let temp = compState.temps.(t) in
> -          match temp with
> -          | TempInt n ->
> -              let newTrail = createNew (Var hp) ~prev:compState.trail in
> -              hp := Int n ;
> -              compState.cp <- compState.cp + 1 ;
> -              compState.trail <- newTrail ;
> -              D.execute compState
> -          | y -> raise (Err (show_variable y)) )
> -      | other -> evalIsHeap other t compState )
> +        match !hp with
> +        | UnboundVar -> (
> +            let temp = compState.temps.(t) in
> +            match temp with
> +            | TempInt n ->
> +                let newTrail = createNew (Var hp) ~prev:compState.trail in
> +                hp := Int n;
> +                compState.cp <- compState.cp + 1;
> +                compState.trail <- newTrail;
> +                D.execute compState
> +            | y -> raise (Err (show_variable y)) )
> +        | other -> evalIsHeap other t compState )
>      | Int n1 -> (
>          let temp = compState.temps.(t) in
>          match temp with
>          | TempInt n2 ->
>              (* logDebug (fun m -> m "eval is heap int expected is %a"pp_intnum n2); *)
>              if n1 = n2 then (
> -              compState.cp <- compState.cp + 1 ;
> +              compState.cp <- compState.cp + 1;
>                D.execute compState )
>              else D.execute (backtrack compState)
>          | y -> raise (Err (show_variable y)) )
> @@ -81,20 +81,21 @@ struct
>      match hval with
>      | Int n2 ->
>          if n1 = n2 then (
> -          compState.cp <- compState.cp + 1 ;
> +          compState.cp <- compState.cp + 1;
>            D.execute compState )
>          else D.execute (backtrack compState)
>      | B hv -> (
> -      match !hv with
> -      | UnboundVar ->
> -          let newTrail = createNew (Var hv) ~prev:compState.trail in
> -          hv := Int n1 ;
> -          (* logDebug (fun m ->  m "Bind makes %a " pp_variable loadedArg); *)
> -          (* logDebug (fun m -> m "getint binding unboundvar to %a" pp_intnum n1 ); *)
> -          compState.cp <- compState.cp + 1 ;
> -          compState.trail <- newTrail ;
> -          D.execute compState
> -      | other -> getintah other compState n1 )
> +        match !hv with
> +        | UnboundVar ->
> +            let newTrail = createNew (Var hv) ~prev:compState.trail in
> +            hv := Int n1;
> +
> +            (* logDebug (fun m ->  m "Bind makes %a " pp_variable loadedArg); *)
> +            (* logDebug (fun m -> m "getint binding unboundvar to %a" pp_intnum n1 ); *)
> +            compState.cp <- compState.cp + 1;
> +            compState.trail <- newTrail;
> +            D.execute compState
> +        | other -> getintah other compState n1 )
>      | _ -> raise Oops
>  
>    let rec getStructure name num location position compState =
> @@ -107,36 +108,38 @@ struct
>      | _ -> raise Oops
>  
>    and getStructureH hval name num compState =
> -    logDebug (fun m -> m "get structureH %a " pp_heapValue hval) ;
> +    logDebug (fun m -> m "get structureH %a " pp_heapValue hval);
>      match hval with
>      | StrPointer (name2, args) ->
>          if name = name2 && num = Array.length args then (
> -          compState.currentStr <- (args, 0) ;
> -          compState.cp <- compState.cp + 1 ;
> +          compState.currentStr <- (args, 0);
> +          compState.cp <- compState.cp + 1;
>            D.execute compState )
>          else (
> -          logDebug (fun m -> m "Unify in get structure failed 1") ;
> +          logDebug (fun m -> m "Unify in get structure failed 1");
>            D.execute (backtrack compState) )
>      | B r -> (
> -      match !r with
> -      | UnboundVar ->
> -          (*IS THIS THE RIGHT INITIAL STATEE *)
> -          let newArray = Array.init num ~f:(fun _ -> B (ref UnboundVar)) in
> -          let newTrail = createNew ~prev:compState.trail (Var r) in
> -          r := StrPointer (name, newArray) ;
> -          (* TODO does this change? *)
> -          compState.currentStr <- (newArray, 0) ;
> -          (* Do I need to add to the trail stack?? *)
> -          compState.cp <- compState.cp + 1 ;
> -          compState.trail <- newTrail ;
> -          logDebug (fun m -> m "Trail bind ") ;
> -          D.execute compState
> -          (* raise Oops *)
> -      | other ->
> -          logDebug (fun m -> m "recursive call getstructh") ;
> -          getStructureH other name num compState )
> +        match !r with
> +        | UnboundVar ->
> +            (*IS THIS THE RIGHT INITIAL STATEE *)
> +            let newArray = Array.init num ~f:(fun _ -> B (ref UnboundVar)) in
> +            let newTrail = createNew ~prev:compState.trail (Var r) in
> +            r := StrPointer (name, newArray);
> +
> +            (* TODO does this change? *)
> +            compState.currentStr <- (newArray, 0);
> +
> +            (* Do I need to add to the trail stack?? *)
> +            compState.cp <- compState.cp + 1;
> +            compState.trail <- newTrail;
> +            logDebug (fun m -> m "Trail bind ");
> +            D.execute compState
> +            (* raise Oops *)
> +        | other ->
> +            logDebug (fun m -> m "recursive call getstructh");
> +            getStructureH other name num compState )
>      | _ ->
> -        logDebug (fun m -> m "Unify in get structure failed") ;
> +        logDebug (fun m -> m "Unify in get structure failed");
>          D.execute (backtrack compState)
>  
>    let putStructure name num location position compState =
> @@ -147,15 +150,15 @@ struct
>        location.(position) <- HeapPointer newHVal
>        (* logDebug (fun m -> m "    put structure %a " pp_varr location) *)
>      in
> -    compState.cp <- compState.cp + 1 ;
> +    compState.cp <- compState.cp + 1;
>      D.execute compState
>  
>    let unifyInFromHeap arr arrpos compState =
>      let heapValueArray, pos = compState.currentStr in
>      let heapTop = heapValueArray.(pos) in
> -    arr.(arrpos) <- HeapPointer heapTop ;
> -    compState.currentStr <- (heapValueArray, pos + 1) ;
> -    compState.cp <- compState.cp + 1 ;
> +    arr.(arrpos) <- HeapPointer heapTop;
> +    compState.currentStr <- (heapValueArray, pos + 1);
> +    compState.cp <- compState.cp + 1;
>      D.execute compState
>  
>    let setValue location position compState =
> @@ -167,9 +170,9 @@ struct
>      | HeapPointer x ->
>          let argArray, pos = compState.currentStr in
>          let () =
> -          argArray.(pos) <- x ;
> +          argArray.(pos) <- x;
>            compState.currentStr <- (argArray, pos + 1)
>          in
> -        compState.cp <- compState.cp + 1 ;
> +        compState.cp <- compState.cp + 1;
>          D.execute compState
>  end
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/execute/unification.ml src/execute/.formatted/unification.ml)
> diff --git a/src/execute/unification.ml b/src/execute/.formatted/unification.ml
> index 7b686fa..35a2d8e 100644
> --- a/src/execute/unification.ml
> +++ b/src/execute/.formatted/unification.ml
> @@ -8,9 +8,9 @@ open StackImplementation
>  let cyclic x y =
>    match x with
>    | B x -> (
> -    match y with
> -    | B yp -> if Core.phys_equal yp x then true else false
> -    | _ -> false )
> +      match y with
> +      | B yp -> if Core.phys_equal yp x then true else false
> +      | _ -> false )
>    | _ -> raise Oops
>  
>  let bind z y trail =
> @@ -23,24 +23,24 @@ let bind z y trail =
>    | _ -> raise Oops
>  
>  let rec rewindTrail trail =
> -  logDebug (fun m -> m "backtrack from rewind trail") ;
> +  logDebug (fun m -> m "backtrack from rewind trail");
>    match trail with
>    | Some node -> (
> -    match node.value with
> -    | Label ->
> -        (* Done *)
> -        logDebug (fun m -> m "finished backtracking") ;
> -        node.prev
> -    | Var hv ->
> -        logDebug (fun m -> m "unbinding from %a" pp_trailVal (Var hv)) ;
> -        hv := UnboundVar ;
> -        rewindTrail node.prev )
> +      match node.value with
> +      | Label ->
> +          (* Done *)
> +          logDebug (fun m -> m "finished backtracking");
> +          node.prev
> +      | Var hv ->
> +          logDebug (fun m -> m "unbinding from %a" pp_trailVal (Var hv));
> +          hv := UnboundVar;
> +          rewindTrail node.prev )
>    | None -> raise (Err "trail empty on rewind")
>  
>  let rewindStack (c : choicePoint node) compState = c.value.stack
>  
>  let backtrack compState =
> -  logDebug (fun m -> m "backtrack") ;
> +  logDebug (fun m -> m "backtrack");
>    match compState.choicePoints with
>    | None -> raise Fail
>    | Some c ->
> @@ -53,26 +53,27 @@ let backtrack compState =
>      | None -> compState.returnCps <- None *)
>        in
>        (* Do i need to update nextOptionPointer somewhere? *)
> -      compState.cp <- c.value.nextOptionPointer ;
> -      compState.trail <- newTrail ;
> +      compState.cp <- c.value.nextOptionPointer;
> +      compState.trail <- newTrail;
> +
>        (* compState.returnTrailPoint <- newTrail; *)
> -      compState.arguments <- Array.copy c.value.arguments ;
> -      compState.returnAddress <- c.value.returnAddr ;
> -      compState.envStack <- rewindStack c compState ;
> -      compState.returnCps <- c.value.returnCps ;
> -      compState.returnTrailPoint <- c.value.returnTrailPoint ;
> +      compState.arguments <- Array.copy c.value.arguments;
> +      compState.returnAddress <- c.value.returnAddr;
> +      compState.envStack <- rewindStack c compState;
> +      compState.returnCps <- c.value.returnCps;
> +      compState.returnTrailPoint <- c.value.returnTrailPoint;
>        if
>          List.exists (getPreds compState.returnCps) ~f:(fun x ->
> -            Some x = compState.choicePoints )
> +            Some x = compState.choicePoints)
>        then raise Oops
> -      else () ;
> +      else ();
>        compState
>  
>  let rec unifyLists xs ys compState =
> -  logDebug (fun m -> m "unify lists") ;
> +  logDebug (fun m -> m "unify lists");
>    let rec unifyListsH xs ys counter compState =
>      if counter >= Array.length xs then (
> -      logDebug (fun m -> m "unify lists done") ;
> +      logDebug (fun m -> m "unify lists done");
>        compState )
>      else
>        (* TODO careful *)
> @@ -91,28 +92,28 @@ and unifyH ah bh compState =
>    | InitH, _ -> raise Oops
>    | _, InitH -> raise Oops
>    | B x, B y -> (
> -      logDebug (fun m -> m "DOUBLE BOUND UNIF") ;
> +      logDebug (fun m -> m "DOUBLE BOUND UNIF");
>        match (!x, !y) with
>        | UnboundVar, UnboundVar ->
> -          compState.trail <- bind (B x) (B y) compState.trail ;
> +          compState.trail <- bind (B x) (B y) compState.trail;
>            compState
>        | UnboundVar, B z -> (
> -        match !z with
> -        | UnboundVar ->
> -            compState.trail <- bind (B x) (B z) compState.trail ;
> -            compState
> -        | _ -> unifyH (B x) !z compState )
> +          match !z with
> +          | UnboundVar ->
> +              compState.trail <- bind (B x) (B z) compState.trail;
> +              compState
> +          | _ -> unifyH (B x) !z compState )
>        | UnboundVar, a ->
> -          compState.trail <- bind (B x) a compState.trail ;
> +          compState.trail <- bind (B x) a compState.trail;
>            compState
>        | B z, UnboundVar -> (
> -        match !z with
> -        | UnboundVar ->
> -            compState.trail <- bind (B y) (B z) compState.trail ;
> -            compState
> -        | _ -> unifyH (B y) !z compState )
> +          match !z with
> +          | UnboundVar ->
> +              compState.trail <- bind (B y) (B z) compState.trail;
> +              compState
> +          | _ -> unifyH (B y) !z compState )
>        | a, UnboundVar ->
> -          compState.trail <- bind (B y) a compState.trail ;
> +          compState.trail <- bind (B y) a compState.trail;
>            compState
>        | _, _ -> unifyH !x !y compState )
>    | B x, y -> tryBind x y compState
> @@ -124,15 +125,15 @@ and unifyH ah bh compState =
>    | Int n1, Int n2 -> if n1 = n2 then compState else backtrack compState
>    | x, y ->
>        logError (fun m ->
> -          m "UnifyH failed: %a %a \n" pp_heapValue x pp_heapValue y ) ;
> +          m "UnifyH failed: %a %a \n" pp_heapValue x pp_heapValue y);
>        backtrack compState
>  
>  and tryBind x y compState =
>    if !x = UnboundVar then
>      if not (cyclic (B x) y) then (
>        let newTrail = createNew (Var x) ~prev:compState.trail in
> -      x := y ;
> -      compState.trail <- newTrail ;
> +      x := y;
> +      compState.trail <- newTrail;
>        compState )
>      else compState
>    else unifyH !x y compState
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/execute/envCpStackOps.ml) > _build/default/src/execute/.formatted/envCpStackOps.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/execute/envCpStackOps.ml src/execute/.formatted/envCpStackOps.ml)
> diff --git a/src/execute/envCpStackOps.ml b/src/execute/.formatted/envCpStackOps.ml
> index 6b8bbae..ca82f64 100644
> --- a/src/execute/envCpStackOps.ml
> +++ b/src/execute/.formatted/envCpStackOps.ml
> @@ -16,7 +16,12 @@ let createEnvironment n ra previousStackHead cps tv =
>    (* logError (fun m -> m "Create env of size %a" pp_intnum n); *)
>    let newArr = Array.create ~len:n InitV in
>    let newEnv =
> -    {vars= newArr; returnAddress= ra; callerCps= cps; callerTrailpoint= tv}
> +    {
> +      vars = newArr;
> +      returnAddress = ra;
> +      callerCps = cps;
> +      callerTrailpoint = tv;
> +    }
>    in
>    StackImplementation.createNew newEnv ~prev:previousStackHead
>  
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/execute/test/executeTest.ml) > _build/default/src/execute/test/.formatted/executeTest.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/main.ml) > _build/default/src/.formatted/main.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/execute/test/executeTest.ml src/execute/test/.formatted/executeTest.ml)
> diff --git a/src/execute/test/executeTest.ml b/src/execute/test/.formatted/executeTest.ml
> index 42900a8..9f8af31 100644
> --- a/src/execute/test/executeTest.ml
> +++ b/src/execute/test/.formatted/executeTest.ml
> @@ -31,6 +31,6 @@ let test1 () =
>    let expected_result = Sexp.of_string "((HeapPointer(B(StrPointer 2()))))" in
>    assert_equal res_sexp expected_result
>  
> -let suite = "Code gen tests" >::: ["test1" >:: test1]
> +let suite = "Code gen tests" >::: [ "test1" >:: test1 ]
>  
>  let _ = run_test_tt_main suite
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/main.ml src/.formatted/main.ml)
> diff --git a/src/main.ml b/src/.formatted/main.ml
> index 0606f9e..ae5728a 100644
> --- a/src/main.ml
> +++ b/src/.formatted/main.ml
> @@ -69,7 +69,7 @@ let perf =
>    \    ?- run\n\
>    \  "
>  
> -type 'a test = {mutable v: 'a} [@@deriving show]
> +type 'a test = { mutable v : 'a } [@@deriving show]
>  
>  let later =
>    "\n\
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/runFromFile.ml) > _build/default/src/.formatted/runFromFile.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/execute/execute.ml) > _build/default/src/execute/.formatted/execute.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/execute/execute.ml src/execute/.formatted/execute.ml)
> diff --git a/src/execute/execute.ml b/src/execute/.formatted/execute.ml
> index 016f40e..41c95d7 100644
> --- a/src/execute/execute.ml
> +++ b/src/execute/.formatted/execute.ml
> @@ -27,10 +27,10 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>      let rec execute compState : 'a option =
>        logDebug (fun m ->
>            m "%a . %a" pp_intnum compState.cp pp_instruction
> -            State.instructions.(compState.cp) ) ;
> +            State.instructions.(compState.cp));
>        logDebug (fun m ->
> -          m "CP stack length: %a" pp_intnum (getLength compState.choicePoints)
> -      ) ;
> +          m "CP stack length: %a" pp_intnum (getLength compState.choicePoints));
> +
>        (* let ss = (Gc.stat() ).stack_size
>           in let () = logError (fun m -> m "%a" pp_intnum ss) *)
>        (* in *)
> @@ -49,36 +49,39 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>        | TryMeElse (PositionC n), _, _ ->
>            (*Set up a choice point*)
>            let newChoicePoint =
> -            { nextOptionPointer= n
> -            ; stack= envStack
> -            ; arguments= Array.copy compState.arguments
> -            ; returnAddr= compState.returnAddress
> -            ; returnCps= compState.returnCps
> -            ; returnTrailPoint= compState.returnTrailPoint }
> +            {
> +              nextOptionPointer = n;
> +              stack = envStack;
> +              arguments = Array.copy compState.arguments;
> +              returnAddr = compState.returnAddress;
> +              returnCps = compState.returnCps;
> +              returnTrailPoint = compState.returnTrailPoint;
> +            }
>            in
> -          compState.trail <- createNew Label ~prev:compState.trail ;
> -          compState.choicePoints
> -          <- Some {prev= choicePoints; value= newChoicePoint} ;
> -          compState.cp <- compState.cp + 1 ;
> -          compState.infinal <- false ;
> +          compState.trail <- createNew Label ~prev:compState.trail;
> +          compState.choicePoints <-
> +            Some { prev = choicePoints; value = newChoicePoint };
> +          compState.cp <- compState.cp + 1;
> +          compState.infinal <- false;
>            execute compState
>        | RetryMeElse (PositionC n), Some c, _ ->
>            (*Update a choice point*)
>            let () = updateChoicePoint n c.value in
> -          compState.trail <- createNew Label ~prev:compState.trail ;
> -          compState.cp <- compState.cp + 1 ;
> -          compState.infinal <- false ;
> +          compState.trail <- createNew Label ~prev:compState.trail;
> +          compState.cp <- compState.cp + 1;
> +          compState.infinal <- false;
>            execute compState
>        | TrustMe, Some c, _ ->
>            (*Discard a choice point*)
> -          compState.cp <- compState.cp + 1 ;
> +          compState.cp <- compState.cp + 1;
> +
>            (* TODO CHECK THIS LINE *)
>            (* if compState.returnCps = Some(c)
>             then (compState.returnCps <- None; compState.returnTrailPoint <- None)
>             else (); *)
> -          if Some c = c.prev then raise Oops else () ;
> -          compState.choicePoints <- c.prev ;
> -          compState.infinal <- true ;
> +          if Some c = c.prev then raise Oops else ();
> +          compState.choicePoints <- c.prev;
> +          compState.infinal <- true;
>            execute compState
>        | GetVariable (position, Arg a), _, Some env ->
>            let loadedVar = compState.arguments.(a) in
> @@ -90,12 +93,12 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>              | T (Temp e) -> compState.temps.(e) <- loadedVar
>              | E (Env e) -> env.value.vars.(e) <- loadedVar
>            in
> -          compState.cp <- compState.cp + 1 ;
> +          compState.cp <- compState.cp + 1;
>            execute compState
>        | ClearTemp (Temp t), _, _ ->
>            let newHeapVar = HeapPointer (B (ref UnboundVar)) in
> -          compState.temps.(t) <- newHeapVar ;
> -          compState.cp <- compState.cp + 1 ;
> +          compState.temps.(t) <- newHeapVar;
> +          compState.cp <- compState.cp + 1;
>            execute compState
>        | GetInt (Arg a, n1), _, _ ->
>            let loadedArg =
> @@ -113,7 +116,7 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            let oldCp = compState.cp in
>            let newState = unifyS envVar argVar compState in
>            if newState.cp = oldCp then (
> -            compState.cp <- compState.cp + 1 ;
> +            compState.cp <- compState.cp + 1;
>              execute newState )
>            else execute newState
>        | GetStructureA ((name, num), Arg a), _, _ ->
> @@ -122,11 +125,11 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            I.getStructure name num compState.temps t compState
>        | Allocate n, _, (stack : stackVal) ->
>            (*Allocate a new environment*)
> -          compState.cp <- compState.cp + 1 ;
> +          compState.cp <- compState.cp + 1;
>            let _ =
>              if
>                List.exists (getPreds compState.returnCps) ~f:(fun x ->
> -                  Some x = compState.choicePoints )
> +                  Some x = compState.choicePoints)
>              then print_endline "bug2"
>              else ()
>            in
> @@ -144,25 +147,26 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>                  createEnvironment n compState.returnAddress None
>                    compState.returnCps compState.returnTrailPoint
>            in
> -          compState.envStack <- newEnv ;
> +          compState.envStack <- newEnv;
>            execute compState
>        | DeallocateBeforeLastCall, _, Some stack ->
>            (*Discard an environemnt*)
>            let newStackVal =
>              match stack.prev with Some prev -> Some prev | None -> raise Oops
>            in
> -          compState.returnAddress <- stack.value.returnAddress ;
> -          compState.envStack <- newStackVal ;
> -          compState.cp <- compState.cp + 1 ;
> -          compState.infinal <- true ;
> +          compState.returnAddress <- stack.value.returnAddress;
> +          compState.envStack <- newStackVal;
> +          compState.cp <- compState.cp + 1;
> +          compState.infinal <- true;
> +
>            (* TODO CHECK *)
>            (* compState.returnCps <- stack.value.callerCps;
>          compState.returnTrailPoint <- stack.value.callerTrailpoint; *)
>            if
>              List.exists (getPreds compState.returnCps) ~f:(fun x ->
> -                Some x = compState.choicePoints )
> +                Some x = compState.choicePoints)
>            then raise Oops
> -          else () ;
> +          else ();
>            execute compState
>        | Deallocate, _, Some stack ->
>            (*Discard an environemnt*)
> @@ -171,17 +175,18 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            in
>            (* logDebug(fun m -> m "cp is %a" pp_intnum compState.cp); *)
>            (* logDebug(fun m -> m "cp set to %a" pp_intnum (stack.value.returnAddress)); *)
> -          compState.cp <- stack.value.returnAddress ;
> -          compState.envStack <- newStackVal ;
> -          compState.infinal <- true ;
> +          compState.cp <- stack.value.returnAddress;
> +          compState.envStack <- newStackVal;
> +          compState.infinal <- true;
> +
>            (* TODO CHECK *)
>            (* compState.returnCps <- stack.value.callerCps;
>          compState.returnTrailPoint <- stack.value.callerTrailpoint; *)
>            if
>              List.exists (getPreds compState.returnCps) ~f:(fun x ->
> -                Some x = compState.choicePoints )
> +                Some x = compState.choicePoints)
>            then print_endline "bug184"
> -          else () ;
> +          else ();
>            execute compState
>        | PutVariable (location, Arg a), _, Some env ->
>            (*Put a new unbound variable on the heap and copy it into Vn and Ai*)
> @@ -191,8 +196,8 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>              | T (Temp t) -> compState.temps.(t) <- HeapPointer newHeapVar
>              | E (Env e) -> env.value.vars.(e) <- HeapPointer newHeapVar
>            in
> -          compState.arguments.(a) <- HeapPointer newHeapVar ;
> -          compState.cp <- compState.cp + 1 ;
> +          compState.arguments.(a) <- HeapPointer newHeapVar;
> +          compState.cp <- compState.cp + 1;
>            execute compState
>        | PutValue (location, Arg s), _, Some env ->
>            let toPut =
> @@ -200,8 +205,8 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>              | E (Env e) -> env.value.vars.(e)
>              | T (Temp t) -> compState.temps.(t)
>            in
> -          compState.arguments.(s) <- toPut ;
> -          compState.cp <- compState.cp + 1 ;
> +          compState.arguments.(s) <- toPut;
> +          compState.cp <- compState.cp + 1;
>            execute compState
>        | PutStructureA ((name, num), Arg a), _, _ ->
>            I.putStructure name num compState.arguments a compState
> @@ -211,11 +216,11 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            let argArray, pos = compState.currentStr in
>            let newHeapVar = Int num in
>            let () =
> -            argArray.(pos) <- newHeapVar ;
> +            argArray.(pos) <- newHeapVar;
>              compState.currentStr <- (argArray, pos + 1)
>              (* logDebug (fun m -> m "    Setint gives new argarray %a" pp_heap argArray) *)
>            in
> -          compState.cp <- compState.cp + 1 ;
> +          compState.cp <- compState.cp + 1;
>            execute compState
>        | SetVariable (E (Env e)), _, Some env ->
>            (*Put a new ref cell on the end of the current arguments being built*)
> @@ -225,7 +230,7 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            let newHeapVar = B (ref UnboundVar) in
>            let () = argArray.(pos) <- newHeapVar in
>            let () = env.value.vars.(e) <- HeapPointer newHeapVar in
> -          compState.cp <- compState.cp + 1 ;
> +          compState.cp <- compState.cp + 1;
>            execute compState
>        | SetValue (E (Env e)), _, Some env ->
>            I.setValue env.value.vars e compState
> @@ -238,8 +243,8 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            let newState = unifyH heapTop (Int n1) compState in
>            (* TODO what if unification failed *)
>            if newState.cp = oldCp then (
> -            newState.currentStr <- (heapValueArray, pos + 1) ;
> -            newState.cp <- compState.cp + 1 ;
> +            newState.currentStr <- (heapValueArray, pos + 1);
> +            newState.cp <- compState.cp + 1;
>              execute newState )
>            else execute newState
>        | StructGetValue position, _, Some env ->
> @@ -258,8 +263,8 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>              (* let () = logDebug (fun m -> m "%a %a" pp_intnum oldCp pp_intnum newState.cp) *)
>            in
>            if newState.cp = oldCp then (
> -            newState.currentStr <- (heapValueArray, pos + 1) ;
> -            newState.cp <- compState.cp + 1 ;
> +            newState.currentStr <- (heapValueArray, pos + 1);
> +            newState.cp <- compState.cp + 1;
>              execute newState )
>            else execute newState
>        | StructGetVariable (E (Env e)), _, Some env ->
> @@ -267,9 +272,9 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>        | StructGetVariable (T (Temp e)), _, Some env ->
>            I.unifyInFromHeap compState.temps e compState
>        | PutIntT (Temp t, n), _, _ ->
> -          logError (fun m -> m "HI") ;
> +          logError (fun m -> m "HI");
>            let () =
> -            compState.temps.(t) <- TempInt n ;
> +            compState.temps.(t) <- TempInt n;
>              compState.cp <- compState.cp + 1
>            in
>            execute compState
> @@ -278,7 +283,7 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            match oldVal with
>            | TempInt x ->
>                let () =
> -                compState.temps.(t) <- TempInt (n + x) ;
> +                compState.temps.(t) <- TempInt (n + x);
>                  compState.cp <- compState.cp + 1
>                in
>                execute compState
> @@ -288,7 +293,7 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            match oldVal with
>            | TempInt x ->
>                let () =
> -                compState.temps.(t) <- TempInt (x - n) ;
> +                compState.temps.(t) <- TempInt (x - n);
>                  compState.cp <- compState.cp + 1
>                in
>                execute compState
> @@ -300,7 +305,7 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>        | PutIntA (Arg a, n), _, _ ->
>            let newHVal = HeapPointer (Int n) in
>            let () = compState.arguments.(a) <- newHVal in
> -          compState.cp <- compState.cp + 1 ;
> +          compState.cp <- compState.cp + 1;
>            execute compState
>        | InitAcc (Temp t, position), _, Some env -> (
>            let envV =
> @@ -310,78 +315,79 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            in
>            match envV with
>            | HeapPointer (Int n) ->
> -              compState.temps.(t) <- TempInt n ;
> -              compState.cp <- compState.cp + 1 ;
> +              compState.temps.(t) <- TempInt n;
> +              compState.cp <- compState.cp + 1;
>                execute compState
>            | HeapPointer (B hp) -> (
> -            match !hp with
> -            | Int n ->
> -                compState.temps.(t) <- TempInt n ;
> -                compState.cp <- compState.cp + 1 ;
> -                execute compState
> -            | other -> raise (Err ("Init acc " ^ show_heapValue other)) )
> +              match !hp with
> +              | Int n ->
> +                  compState.temps.(t) <- TempInt n;
> +                  compState.cp <- compState.cp + 1;
> +                  execute compState
> +              | other -> raise (Err ("Init acc " ^ show_heapValue other)) )
>            | x ->
>                raise
>                  (Err ("Try to initialise accumilator to " ^ show_variable x)) )
>        | Is (position, Temp t), _, Some env -> (
> -        (* let envVar = Array.get (env.value.vars) e *)
> -        match position with
> -        | E (Env e) ->
> -            let envVar = env.value.vars.(e) in
> -            I.evalIs envVar t env.value.vars e compState
> -        | T (Temp tmp) ->
> -            let var = compState.temps.(tmp) in
> -            I.evalIs var t compState.temps tmp compState )
> +          (* let envVar = Array.get (env.value.vars) e *)
> +          match position with
> +          | E (Env e) ->
> +              let envVar = env.value.vars.(e) in
> +              I.evalIs envVar t env.value.vars e compState
> +          | T (Temp tmp) ->
> +              let var = compState.temps.(tmp) in
> +              I.evalIs var t compState.temps tmp compState )
>        (* print_endline "hiii guys" *)
> -      
> +
>        (* in logError (fun m -> m "%a" pp_variable envVar); raise Oops *)
>        (* in I.evalIs envVar t env.value.vars e compState *)
>        | Call (PositionF addr), _, _ ->
>            let () =
> -            compState.returnAddress <- compState.cp + 1 ;
> -            compState.cp <- addr ;
> -            compState.returnCps <- choicePoints ;
> +            compState.returnAddress <- compState.cp + 1;
> +            compState.cp <- addr;
> +            compState.returnCps <- choicePoints;
>              compState.returnTrailPoint <- compState.trail
>            in
>            let _ =
>              if
>                List.exists (getPreds compState.returnCps) ~f:(fun x ->
> -                  Some x = compState.choicePoints )
> +                  Some x = compState.choicePoints)
>              then raise Oops
>              else ()
>            in
>            execute compState
>        | CallAfterDealloc (PositionF addr), _, _ ->
>            let () =
> -            compState.cp <- addr ;
> -            compState.returnCps <- choicePoints ;
> +            compState.cp <- addr;
> +            compState.returnCps <- choicePoints;
>              compState.returnTrailPoint <- compState.trail
>            in
>            let _ =
>              if
>                List.exists (getPreds compState.returnCps) ~f:(fun x ->
> -                  Some x = compState.choicePoints )
> +                  Some x = compState.choicePoints)
>              then raise Oops
>              else ()
>            in
>            execute compState
>        | RmCps, _, Some e ->
> -          compState.cp <- compState.cp + 1 ;
> +          compState.cp <- compState.cp + 1;
> +
>            (* in if (compState.infinal) *)
>            (* then  *)
>            let _ =
>              if
>                List.exists (getPreds e.value.callerCps) ~f:(fun x ->
> -                  Some x = compState.choicePoints )
> +                  Some x = compState.choicePoints)
>              then raise (Err "broken rmcps")
>              else ()
>            in
> -          compState.choicePoints <- e.value.callerCps ;
> -          compState.trail <- e.value.callerTrailpoint ;
> +          compState.choicePoints <- e.value.callerCps;
> +          compState.trail <- e.value.callerTrailpoint;
>            let resetHead =
>              e.value.callerCps
>              (* in let _ = raise Oops *)
> -            
> +
>              (* in let _ = ( match resetHead with
>                Some(cp) -> (match (cp.value.stack) with
>                  | Some(env) -> (match e.prev with
> @@ -396,7 +402,7 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>                )
>              | None -> print_endline "3"
>             ) *)
> -            
> +
>              (* in let _ = ( match resetHead with
>                Some((cp : choicePoint node)) ->
>                if ((e.prev) : stackVal) = (cp.value.stack : stackVal)
> @@ -410,7 +416,7 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>              compState.choicePoints <- e.value.callerCps;
>              compState.trail <- e.value.callerTrailpoint
>             ) *)
> -            
> +
>              (* in let _ = (match e.prev with
>              | Some(preve) ->
>                if preve = e
> @@ -419,7 +425,7 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>                else   print_endline "2"
>  
>              | None -> ()) *)
> -            
> +
>              (* match (resetHead.stackVal) with
>             | Some(env) ->
>                     if env = e
> @@ -431,21 +437,21 @@ module DriverAndFunctions (State : StateTyp) : DriverAndFunctionsTyp = struct
>            execute compState
>        | Backtrack, _, _ -> execute (backtrack compState)
>        | Finish, _, Some e -> (
> -        match !State.resCount with
> -        | 1 -> Some e.value
> -        | n ->
> -            State.resCount := n - 1 ;
> -            let thisans = e.value.vars in
> -            let flat =
> -              List.map ~f:(flattenSv State.structMap) (Array.to_list thisans)
> -            in
> -            logError (fun m -> m "%a \n" pp_res flat) ;
> -            execute (backtrack compState) )
> +          match !State.resCount with
> +          | 1 -> Some e.value
> +          | n ->
> +              State.resCount := n - 1;
> +              let thisans = e.value.vars in
> +              let flat =
> +                List.map ~f:(flattenSv State.structMap) (Array.to_list thisans)
> +              in
> +              logError (fun m -> m "%a \n" pp_res flat);
> +              execute (backtrack compState) )
>        | other, _, _ -> raise (InstrNotMatch (show_instruction other))
>    end
>  
>    module rec DriverImpl : DriverTyp = Driver (InstructionImplementationsImpl)
> -  
> +
>    and InstructionImplementationsImpl : InstructionFunctionsTyp =
>      InstructionImplementations (DriverImpl)
>  end
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/endToEndTest.ml) > _build/default/src/.formatted/endToEndTest.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/writeToFile.ml) > _build/default/src/.formatted/writeToFile.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/writeToFile.ml src/.formatted/writeToFile.ml)
> diff --git a/src/writeToFile.ml b/src/.formatted/writeToFile.ml
> index 70b9c3f..e26ddbe 100644
> --- a/src/writeToFile.ml
> +++ b/src/.formatted/writeToFile.ml
> @@ -32,8 +32,8 @@ let queen12 =
>       perm(c(1,c(2,c(3,c(4,c(5,c(6,c(7,c(8,eol)))))))),R), checkDiags(R).\n\n\n\n\
>      \      ?-  \
>       perm(c(1,c(2,c(3,c(4,c(5,c(6,c(7,c(8,c(9,c(10,c(11,c(12,eol)))))))))))),R), \
> -     checkDiags(R)"
> -  , "12queen" )
> +     checkDiags(R)",
> +    "12queen" )
>  
>  let load_file f = In_channel.read_all f
>  
> @@ -59,8 +59,8 @@ let queen4 =
>      \                    checkDiags(c(X,eol)).\n\
>      \                    checkDiags(c(Q1,T)) :- checkHead(c(Q1,T),0), \
>       checkDiags(T).\n\n\n\n\
> -    \            ?-  perm(c(1,c(2,c(3,c(4,eol)))),R), checkDiags(R)"
> -  , "4queen" )
> +    \            ?-  perm(c(1,c(2,c(3,c(4,eol)))),R), checkDiags(R)",
> +    "4queen" )
>  
>  let write () =
>    let name = Sys.argv.(1) in
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/logging.ml) > _build/default/src/interpreter/.formatted/logging.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/logging.ml src/interpreter/.formatted/logging.ml)
> diff --git a/src/interpreter/logging.ml b/src/interpreter/.formatted/logging.ml
> index 520e398..7250783 100644
> --- a/src/interpreter/logging.ml
> +++ b/src/interpreter/.formatted/logging.ml
> @@ -2,8 +2,8 @@ open Logs
>  
>  let myLog =
>    let log = Logs.Src.create "logs" in
> -  Logs.set_level (Some Debug) ;
> -  Logs.set_reporter (Logs_fmt.reporter ~pp_header:Fmt.nop ()) ;
> +  Logs.set_level (Some Debug);
> +  Logs.set_reporter (Logs_fmt.reporter ~pp_header:Fmt.nop ());
>    log
>  
>  let logDebug msg = Logs.debug ~src:myLog msg
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --intf src/interpreter/prolog_lexer_parser/parser.mli) > _build/default/src/interpreter/prolog_lexer_parser/.formatted/parser.mli
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/prolog_lexer_parser/parseTree.ml) > _build/default/src/interpreter/prolog_lexer_parser/.formatted/parseTree.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/prolog_lexer_parser/parseTree.ml src/interpreter/prolog_lexer_parser/.formatted/parseTree.ml)
> diff --git a/src/interpreter/prolog_lexer_parser/parseTree.ml b/src/interpreter/prolog_lexer_parser/.formatted/parseTree.ml
> index bc6a8ac..0877cd9 100644
> --- a/src/interpreter/prolog_lexer_parser/parseTree.ml
> +++ b/src/interpreter/prolog_lexer_parser/.formatted/parseTree.ml
> @@ -26,7 +26,7 @@ let () =
>  
>  let rec strAll f = function
>    | [] -> ""
> -  | [x] -> f x
> +  | [ x ] -> f x
>    | x :: xs -> f x ^ ";" ^ strAll f xs
>  
>  let rec strTerm = function
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/interp.ml) > _build/default/src/interpreter/.formatted/interp.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/interp.ml src/interpreter/.formatted/interp.ml)
> diff --git a/src/interpreter/interp.ml b/src/interpreter/.formatted/interp.ml
> index 8172de1..c2fff69 100644
> --- a/src/interpreter/interp.ml
> +++ b/src/interpreter/.formatted/interp.ml
> @@ -10,7 +10,7 @@ let setIfNotAlready hashT key value =
>      let _ = Hashtbl.find hashT key in
>      ()
>    with Not_found ->
> -    Hashtbl.add hashT key value ;
> +    Hashtbl.add hashT key value;
>      ()
>  
>  (*Map from string variable to placeholder*)
> @@ -18,16 +18,16 @@ let genArgMap ag =
>    let rec genArgumentMapH arguments hashT counter =
>      match arguments with
>      | x :: xs -> (
> -      match x with
> -      | TVar var ->
> -          let arg = Argument counter in
> -          (* Printf.printf "Arg map plus %s -> %s" var (genStringPlaceholder arg);
> +        match x with
> +        | TVar var ->
> +            let arg = Argument counter in
> +            (* Printf.printf "Arg map plus %s -> %s" var (genStringPlaceholder arg);
>              print_endline ""; *)
> -          setIfNotAlready hashT var arg ;
> -          genArgumentMapH xs hashT (counter + 1)
> -      | TFun (_, ts) ->
> -          let newT, newC = genArgumentMapH ts hashT counter in
> -          genArgumentMapH xs newT newC )
> +            setIfNotAlready hashT var arg;
> +            genArgumentMapH xs hashT (counter + 1)
> +        | TFun (_, ts) ->
> +            let newT, newC = genArgumentMapH ts hashT counter in
> +            genArgumentMapH xs newT newC )
>      | [] -> (hashT, counter)
>    in
>    let table, _ = genArgumentMapH ag (Hashtbl.create 100) 0 in
> @@ -36,17 +36,17 @@ let genArgMap ag =
>  let rec applyArgMapToTerm argmap count term =
>    match term with
>    | TVar var -> (
> -    try
> -      (* Printf.printf "Lookup %s \n" var; *)
> -      let found = Hashtbl.find argmap var in
> -      (* print_endline "argument var"; *)
> -      TVar found
> -    with Not_found ->
> -      (* print_endline "inner var"; *)
> -      let newVar = Inner !count in
> -      Hashtbl.add argmap var newVar ;
> -      count := !count + 1 ;
> -      TVar newVar )
> +      try
> +        (* Printf.printf "Lookup %s \n" var; *)
> +        let found = Hashtbl.find argmap var in
> +        (* print_endline "argument var"; *)
> +        TVar found
> +      with Not_found ->
> +        (* print_endline "inner var"; *)
> +        let newVar = Inner !count in
> +        Hashtbl.add argmap var newVar;
> +        count := !count + 1;
> +        TVar newVar )
>    | TFun (name, ts) -> TFun (name, map (applyArgMapToTerm argmap count) ts)
>  
>  let makeGoalsAbstract gs =
> @@ -105,7 +105,7 @@ let genFunctionTable (Sentence cls) =
>      match clauses with
>      | [] -> hashT
>      | Clause (head, body) :: cs ->
> -        Hashtbl.add hashT (genFunctionId head) (Clause (head, body)) ;
> +        Hashtbl.add hashT (genFunctionId head) (Clause (head, body));
>          genFunctionTableH cs hashT
>    in
>    genFunctionTableH cls (Hashtbl.create 100)
> @@ -113,13 +113,13 @@ let genFunctionTable (Sentence cls) =
>  let rec map f xs = match xs with y :: ys -> f y :: map f ys | [] -> []
>  
>  let printUnifier hashT =
> -  print_endline "The unifier is:" ;
> +  print_endline "The unifier is:";
>    Hashtbl.fold
>      (fun key value _ ->
>        Printf.printf "%s -> %s\n"
>          (show_term pp_placeholder key)
> -        (show_term pp_placeholder value) )
> -    hashT () ;
> +        (show_term pp_placeholder value))
> +    hashT ();
>    print_endline ""
>  
>  exception Oops
> @@ -152,20 +152,22 @@ let rec unifyTermLists t1s t2s bottomSub topSub =
>    | [], _ -> Failure
>    | _, [] -> Failure
>    | t1 :: t1ss, t2 :: t2ss -> (
> -    match
> -      unifyTerm
> -        (applyUnifier bottomSub t1)
> -        (applyUnifier topSub t2) bottomSub topSub
> -    with
> -    | Success -> unifyTermLists t1ss t2ss bottomSub topSub
> -    | Failure -> Failure )
> +      match
> +        unifyTerm
> +          (applyUnifier bottomSub t1)
> +          (applyUnifier topSub t2) bottomSub topSub
> +      with
> +      | Success -> unifyTermLists t1ss t2ss bottomSub topSub
> +      | Failure -> Failure )
>  
>  and unifyTerm t1 t2 bottomSub topSub =
>    match (t1, t2) with
>    | TVar _, _ ->
> -      Hashtbl.add bottomSub t1 t2 ;
> +      Hashtbl.add bottomSub t1 t2;
> +      Success
> +  | _, TVar _ ->
> +      Hashtbl.add topSub t2 t1;
>        Success
> -  | _, TVar _ -> Hashtbl.add topSub t2 t1 ; Success
>    | TFun (funct1, ts1), TFun (funct2, ts2) ->
>        if funct1 = funct2 then unifyTermLists ts1 ts2 bottomSub topSub
>        else Failure
> @@ -220,9 +222,11 @@ let prove functionT goals =
>        match terms with
>        | [] -> ()
>        | TVar v :: ts ->
> -          Hashtbl.replace hash (TVar v) (TVar v) ;
> +          Hashtbl.replace hash (TVar v) (TVar v);
>            baseTs ts
> -      | TFun (_, ts) :: tss -> baseTs ts ; baseTs tss
> +      | TFun (_, ts) :: tss ->
> +          baseTs ts;
> +          baseTs tss
>      in
>      let _ = map (fun (Atom (_pred, terms)) -> baseTs terms) goals in
>      hash
> @@ -232,64 +236,66 @@ let prove functionT goals =
>      match goals with
>      | [] -> s
>      | g :: gs -> (
> -      try
> -        let () =
> -          logDebug (fun m -> m "prove goal  %a" (pp_atom pp_placeholder) g)
> -        in
> -        (* get substitution for g *)
> -        let subst =
> +        try
> +          let () =
> +            logDebug (fun m -> m "prove goal  %a" (pp_atom pp_placeholder) g)
> +          in
> +          (* get substitution for g *)
> +          let subst =
> +            match clauses with
> +            | [] -> raise Backtrack
> +            | Clause (head, elems) :: _ -> (
> +                match unifyAtom g head with
> +                | None -> raise Backtrack
> +                | Some (bottomSub, topSub) -> (
> +                    let newGoalsInsideChosenClause =
> +                      map (atomSubst topSub) elems
> +                    in
> +                    let newS = concat topSub bottomSub in
> +                    match newGoalsInsideChosenClause with
> +                    | [] ->
> +                        (* let () = logDebug (fun m -> m "new goals are empty") *)
> +                        (* in *)
> +                        (* TODO WHAT SUB *)
> +                        (* let () = logDebug (fun m -> m "not after ngs") in *)
> +                        newS
> +                    | x :: _ ->
> +                        let id = genFunctionId x in
> +                        let nclauses =
> +                          reverse (Hashtbl.find_all functionT id)
> +                        in
> +                        let s =
> +                          proveAll newGoalsInsideChosenClause nclauses newS
> +                          (* in let () =  printUnifier newS *)
> +                          (* in let () =  printUnifier bottomSub *)
> +                          (* in let () =  printUnifier topSub *)
> +                          (* in let () = logDebug (fun m -> m "after ngs") *)
> +                        in
> +                        s ) )
> +          in
> +          (* let ()  = printUnifier subst in *)
> +          let () =
> +            logDebug (fun m ->
> +                m " translated goal is  %a" (pp_atom pp_placeholder)
> +                  (atomSubst subst g))
> +          in
> +          let remainingGoals = (map (fun atom -> atomSubst subst atom)) gs in
> +          (* let () = logDebug (fun m -> m "remainingGoals  %a" (pp_pal) remainingGoals) *)
> +          let newsub = concat subst s in
> +          match remainingGoals with
> +          | [] -> newsub
> +          | x :: _ ->
> +              let id = genFunctionId x in
> +              let nclauses = reverse (Hashtbl.find_all functionT id) in
> +              proveAll remainingGoals nclauses newsub
> +        with Backtrack -> (
>            match clauses with
>            | [] -> raise Backtrack
> -          | Clause (head, elems) :: _ -> (
> -            match unifyAtom g head with
> -            | None -> raise Backtrack
> -            | Some (bottomSub, topSub) -> (
> -                let newGoalsInsideChosenClause =
> -                  map (atomSubst topSub) elems
> -                in
> -                let newS = concat topSub bottomSub in
> -                match newGoalsInsideChosenClause with
> -                | [] ->
> -                    (* let () = logDebug (fun m -> m "new goals are empty") *)
> -                    (* in *)
> -                    (* TODO WHAT SUB *)
> -                    (* let () = logDebug (fun m -> m "not after ngs") in *)
> -                    newS
> -                | x :: _ ->
> -                    let id = genFunctionId x in
> -                    let nclauses = reverse (Hashtbl.find_all functionT id) in
> -                    let s =
> -                      proveAll newGoalsInsideChosenClause nclauses newS
> -                      (* in let () =  printUnifier newS *)
> -                      (* in let () =  printUnifier bottomSub *)
> -                      (* in let () =  printUnifier topSub *)
> -                      (* in let () = logDebug (fun m -> m "after ngs") *)
> -                    in
> -                    s ) )
> -        in
> -        (* let ()  = printUnifier subst in *)
> -        let () =
> -          logDebug (fun m ->
> -              m " translated goal is  %a" (pp_atom pp_placeholder)
> -                (atomSubst subst g) )
> -        in
> -        let remainingGoals = (map (fun atom -> atomSubst subst atom)) gs in
> -        (* let () = logDebug (fun m -> m "remainingGoals  %a" (pp_pal) remainingGoals) *)
> -        let newsub = concat subst s in
> -        match remainingGoals with
> -        | [] -> newsub
> -        | x :: _ ->
> -            let id = genFunctionId x in
> -            let nclauses = reverse (Hashtbl.find_all functionT id) in
> -            proveAll remainingGoals nclauses newsub
> -      with Backtrack -> (
> -        match clauses with
> -        | [] -> raise Backtrack
> -        | _ :: cs ->
> -            let () = logDebug (fun m -> m "backtrack to next goal") in
> -            proveAll goals cs s ) )
> +          | _ :: cs ->
> +              let () = logDebug (fun m -> m "backtrack to next goal") in
> +              proveAll goals cs s ) )
>      (* proveAll remainingGoals newsub *)
> -    
> +
>      (*
>    and getClauseGoals goal clauses s bts  : ('e * 'f * 'g)option=
>      match clauses with
> @@ -329,7 +335,7 @@ let prove functionT goals =
>           | Some(ns,nbts) ->
>             let ngs = map (atomSubst ns) gs
>             in proveAll ngs ns nbts *)
> -    
> +
>      (* and tryProof subst bts s gs =
>       match subst with
>       | None -> backTrack bts
> @@ -356,9 +362,11 @@ let genBase goals hash =
>      match terms with
>      | [] -> ()
>      | TVar v :: ts ->
> -        Hashtbl.replace hash (TVar v) (TVar v) ;
> +        Hashtbl.replace hash (TVar v) (TVar v);
>          baseTs ts
> -    | TFun (_, ts) :: tss -> baseTs ts ; baseTs tss
> +    | TFun (_, ts) :: tss ->
> +        baseTs ts;
> +        baseTs tss
>    in
>    let _ = map (fun (Atom (_pred, terms)) -> baseTs terms) goals in
>    hash
> @@ -371,7 +379,7 @@ let rec genStringTerm term =
>  let genStringAtom (Atom (pred, ts)) = Atom (pred, map genStringTerm ts)
>  
>  let interpret prog =
> -  print_endline "interpret" ;
> +  print_endline "interpret";
>    let (Program (Sentence clauses, Resolvant goals)) =
>      makeProgramAbstract prog
>    in
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/prolog_lexer_parser/lexer.ml) > _build/default/src/interpreter/prolog_lexer_parser/.formatted/lexer.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/prolog_lexer_parser/lexer.ml src/interpreter/prolog_lexer_parser/.formatted/lexer.ml)
> diff --git a/src/interpreter/prolog_lexer_parser/lexer.ml b/src/interpreter/prolog_lexer_parser/.formatted/lexer.ml
> index 2e2ae4f..b35bfbe 100644
> --- a/src/interpreter/prolog_lexer_parser/lexer.ml
> +++ b/src/interpreter/prolog_lexer_parser/.formatted/lexer.ml
> @@ -3,22 +3,24 @@ open Parser
>  (* The type token is defined in parser.mli *)
>  
>  let __ocaml_lex_tables =
> -  { Lexing.lex_base=
> -      "\000\000\002\000\000\000\248\255\002\000\250\255\251\255\252\255\253\255\075\000\160\000\249\255\247\255"
> -  ; Lexing.lex_backtrk=
> -      "\255\255\009\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\001\000\000\000\255\255\255\255"
> -  ; Lexing.lex_default=
> -      "\255\255\255\255\255\255\000\000\255\255\000\000\000\000\000\000\000\000\255\255\255\255\000\000\000\000"
> -  ; Lexing.lex_trans=
> -      "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\001\000\001\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\008\000\007\000\000\000\000\000\005\000\012\000\003\000\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\002\000\000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\000\000\000\000\000\000\000\000\000\000\006\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
> -  ; Lexing.lex_check=
> -      "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\001\000\001\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\001\000\255\255\255\255\255\255\255\255\255\255\000\000\000\000\255\255\255\255\000\000\002\000\000\000\004\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255"
> -  ; Lexing.lex_base_code= ""
> -  ; Lexing.lex_backtrk_code= ""
> -  ; Lexing.lex_default_code= ""
> -  ; Lexing.lex_trans_code= ""
> -  ; Lexing.lex_check_code= ""
> -  ; Lexing.lex_code= "" }
> +  {
> +    Lexing.lex_base =
> +      "\000\000\002\000\000\000\248\255\002\000\250\255\251\255\252\255\253\255\075\000\160\000\249\255\247\255";
> +    Lexing.lex_backtrk =
> +      "\255\255\009\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\001\000\000\000\255\255\255\255";
> +    Lexing.lex_default =
> +      "\255\255\255\255\255\255\000\000\255\255\000\000\000\000\000\000\000\000\255\255\255\255\000\000\000\000";
> +    Lexing.lex_trans =
> +      "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\001\000\001\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\008\000\007\000\000\000\000\000\005\000\012\000\003\000\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\002\000\000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\000\000\000\000\000\000\000\000\000\000\006\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000";
> +    Lexing.lex_check =
> +      "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\001\000\001\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\001\000\255\255\255\255\255\255\255\255\255\255\000\000\000\000\255\255\255\255\000\000\002\000\000\000\004\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255";
> +    Lexing.lex_base_code = "";
> +    Lexing.lex_backtrk_code = "";
> +    Lexing.lex_default_code = "";
> +    Lexing.lex_trans_code = "";
> +    Lexing.lex_check_code = "";
> +    Lexing.lex_code = "";
> +  }
>  
>  let rec token lexbuf = __ocaml_lex_token_rec lexbuf 0
>  
> @@ -45,5 +47,5 @@ and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
>    | 8 -> QUES
>    | 9 -> token lexbuf
>    | __ocaml_lex_state ->
> -      lexbuf.Lexing.refill_buff lexbuf ;
> +      lexbuf.Lexing.refill_buff lexbuf;
>        __ocaml_lex_token_rec lexbuf __ocaml_lex_state
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/test/useInterpreter7.ml) > _build/default/src/interpreter/test/.formatted/useInterpreter7.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/test/useParser.ml) > _build/default/src/interpreter/test/.formatted/useParser.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/test/useParser.ml src/interpreter/test/.formatted/useParser.ml)
> diff --git a/src/interpreter/test/useParser.ml b/src/interpreter/test/.formatted/useParser.ml
> index 1e03317..eaaec34 100644
> --- a/src/interpreter/test/useParser.ml
> +++ b/src/interpreter/test/.formatted/useParser.ml
> @@ -3,4 +3,5 @@ let test_case = "\nanimal(X) :- cat(X).\ncat(fluffy).\n\n?- animal(fluffy)\n"
>  let () =
>    let lexbuf = Lexing.from_string test_case in
>    let _result = Parser.main Lexer.token lexbuf in
> -  print_string "\n" ; print_string "\n\n"
> +  print_string "\n";
> +  print_string "\n\n"
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/test/useInterpreter7.ml src/interpreter/test/.formatted/useInterpreter7.ml)
> diff --git a/src/interpreter/test/useInterpreter7.ml b/src/interpreter/test/.formatted/useInterpreter7.ml
> index 63a8bdb..9691f54 100644
> --- a/src/interpreter/test/useInterpreter7.ml
> +++ b/src/interpreter/test/.formatted/useInterpreter7.ml
> @@ -21,8 +21,8 @@ let test_case =
>     ?- perm(c(n1,c(n2,eol)),R), checkHeadDiffNot1(R)\n"
>  
>  let () =
> -  Printf.printf "Interp 4\n" ;
> -  print_endline "\n" ;
> +  Printf.printf "Interp 4\n";
> +  print_endline "\n";
>    let lexbuf = Lexing.from_string test_case in
>    let parseTree = Parser.main Lexer.token lexbuf in
>    let result = interpret parseTree in
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/test/interpreterTest7.ml) > _build/default/src/interpreter/test/.formatted/interpreterTest7.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/test/interpreterTest7.ml src/interpreter/test/.formatted/interpreterTest7.ml)
> diff --git a/src/interpreter/test/interpreterTest7.ml b/src/interpreter/test/.formatted/interpreterTest7.ml
> index e596e3f..7dc4ea4 100644
> --- a/src/interpreter/test/interpreterTest7.ml
> +++ b/src/interpreter/test/.formatted/interpreterTest7.ml
> @@ -15,7 +15,7 @@ let testInterpreter input_str expected_result =
>  let basic_true () =
>    testInterpreter
>      "\n  animal(X) :- cat(X).\n  cat(fluffy).\n\n  ?- animal(fluffy)\n  "
> -    (Ans (Resolvant [Atom ("animal", [TFun ("fluffy", [])])]))
> +    (Ans (Resolvant [ Atom ("animal", [ TFun ("fluffy", []) ]) ]))
>  
>  let basic_false () =
>    testInterpreter
> @@ -23,7 +23,7 @@ let basic_false () =
>  
>  let unification () =
>    testInterpreter "\n  animal(dusk).\n  ?- animal(X)\n  "
> -    (Ans (Resolvant [Atom ("animal", [TFun ("dusk", [])])]))
> +    (Ans (Resolvant [ Atom ("animal", [ TFun ("dusk", []) ]) ]))
>  
>  let basic_backtrack () =
>    testInterpreter
> @@ -35,21 +35,24 @@ let basic_backtrack () =
>      \  "
>      (Ans
>         (Resolvant
> -          [ Atom ("animal", [TFun ("dusk", [])])
> -          ; Atom ("dog", [TFun ("dusk", [])]) ]))
> +          [ Atom ("animal", [ TFun ("dusk", []) ]);
> +            Atom ("dog", [ TFun ("dusk", []) ])
> +          ]))
>  
>  let repeat_var () =
>    testInterpreter
>      "\n  nextTo(house,car).\n  nextTo(tree,tree).\n  ?- nextTo(X,X)\n  "
> -    (Ans (Resolvant [Atom ("nextTo", [TFun ("tree", []); TFun ("tree", [])])]))
> +    (Ans
> +       (Resolvant [ Atom ("nextTo", [ TFun ("tree", []); TFun ("tree", []) ]) ]))
>  
>  let two_var () =
>    testInterpreter
>      "\n    person(craig).\n    dog(dusk).\n    ?- person(X), dog(Y)\n    "
>      (Ans
>         (Resolvant
> -          [ Atom ("person", [TFun ("craig", [])])
> -          ; Atom ("dog", [TFun ("dusk", [])]) ]))
> +          [ Atom ("person", [ TFun ("craig", []) ]);
> +            Atom ("dog", [ TFun ("dusk", []) ])
> +          ]))
>  
>  let false_1 () =
>    testInterpreter
> @@ -58,36 +61,38 @@ let false_1 () =
>  let priority_order () =
>    testInterpreter
>      "\n    animal(dusk).\n    animal(craig).\n    ?- animal(X)\n    "
> -    (Ans (Resolvant [Atom ("animal", [TFun ("dusk", [])])]))
> +    (Ans (Resolvant [ Atom ("animal", [ TFun ("dusk", []) ]) ]))
>  
>  let t9 () =
>    testInterpreter
>      "\n   person(craig).\n   dog(dusk).\n   ?- person(X), dog(Y)\n   "
>      (Ans
>         (Resolvant
> -          [ Atom ("person", [TFun ("craig", [])])
> -          ; Atom ("dog", [TFun ("dusk", [])]) ]))
> +          [ Atom ("person", [ TFun ("craig", []) ]);
> +            Atom ("dog", [ TFun ("dusk", []) ])
> +          ]))
>  
>  let no_swaps () =
>    testInterpreter
>      "\ng(dusk).\nh(craig).\n\nf(A,B) :- g(A), h(B).\n\n?-f(Y,X)\n"
> -    (Ans (Resolvant [Atom ("f", [TFun ("dusk", []); TFun ("craig", [])])]))
> +    (Ans (Resolvant [ Atom ("f", [ TFun ("dusk", []); TFun ("craig", []) ]) ]))
>  
>  let swaps1 () =
>    testInterpreter
>      "\ng(dusk).\nh(craig).\n\nf(X,Y) :- g(X), h(Y).\n\n?-f(Y,X)\n  "
> -    (Ans (Resolvant [Atom ("f", [TFun ("dusk", []); TFun ("craig", [])])]))
> +    (Ans (Resolvant [ Atom ("f", [ TFun ("dusk", []); TFun ("craig", []) ]) ]))
>  
>  let swaps2 () =
>    testInterpreter
>      "\ng(dusk).\nh(craig).\n\nf(X,Y) :- g(Y), h(X).\n\n?-f(Y,X)\n"
> -    (Ans (Resolvant [Atom ("f", [TFun ("craig", []); TFun ("dusk", [])])]))
> +    (Ans (Resolvant [ Atom ("f", [ TFun ("craig", []); TFun ("dusk", []) ]) ]))
>  
>  let structarg () =
>    testInterpreter "\nplant(flower(X)).\n\n?- plant(X)\n"
>      (Ans
>         (Resolvant
> -          [Atom ("plant", [TFun ("flower", [TVar "(Interp.Argument 0)"])])]))
> +          [ Atom ("plant", [ TFun ("flower", [ TVar "(Interp.Argument 0)" ]) ])
> +          ]))
>  
>  let addOne () =
>    testInterpreter
> @@ -98,10 +103,12 @@ let addOne () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "add"
> -              , [ TFun ("zero", [])
> -                ; TFun ("s", [TFun ("zero", [])])
> -                ; TFun ("s", [TFun ("zero", [])]) ] ) ]))
> +              ( "add",
> +                [ TFun ("zero", []);
> +                  TFun ("s", [ TFun ("zero", []) ]);
> +                  TFun ("s", [ TFun ("zero", []) ])
> +                ] )
> +          ]))
>  
>  let onePlusOne () =
>    testInterpreter
> @@ -112,29 +119,36 @@ let onePlusOne () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "add"
> -              , [ TFun ("s", [TFun ("zero", [])])
> -                ; TFun ("s", [TFun ("zero", [])])
> -                ; TFun ("s", [TFun ("s", [TFun ("zero", [])])]) ] ) ]))
> +              ( "add",
> +                [ TFun ("s", [ TFun ("zero", []) ]);
> +                  TFun ("s", [ TFun ("zero", []) ]);
> +                  TFun ("s", [ TFun ("s", [ TFun ("zero", []) ]) ])
> +                ] )
> +          ]))
>  
>  let alpha1 () =
>    testInterpreter "\nf(X).\n\n?- f(struct(X))\n"
> -    (Ans (Resolvant [Atom ("f", [TFun ("struct", [TVar "(Interp.Inner 0)"])])]))
> +    (Ans
> +       (Resolvant
> +          [ Atom ("f", [ TFun ("struct", [ TVar "(Interp.Inner 0)" ]) ]) ]))
>  
>  let alpha2 () =
>    testInterpreter "\nf(struct(X)).\n\n?- f(X)\n"
>      (Ans
> -       (Resolvant [Atom ("f", [TFun ("struct", [TVar "(Interp.Argument 0)"])])]))
> +       (Resolvant
> +          [ Atom ("f", [ TFun ("struct", [ TVar "(Interp.Argument 0)" ]) ]) ]))
>  
>  let alpha3 () =
>    testInterpreter "\ng(build(X)).\nf(struct(X)) :- g(X).\n\n?- f(X)\n"
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "f"
> -              , [ TFun
> -                    ("struct", [TFun ("build", [TVar "(Interp.Argument 0)"])])
> -                ] ) ]))
> +              ( "f",
> +                [ TFun
> +                    ( "struct",
> +                      [ TFun ("build", [ TVar "(Interp.Argument 0)" ]) ] )
> +                ] )
> +          ]))
>  
>  let zeroTwo () =
>    testInterpreter
> @@ -145,10 +159,12 @@ let zeroTwo () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "add"
> -              , [ TFun ("zero", [])
> -                ; TFun ("s", [TFun ("s", [TFun ("zero", [])])])
> -                ; TFun ("s", [TFun ("s", [TFun ("zero", [])])]) ] ) ]))
> +              ( "add",
> +                [ TFun ("zero", []);
> +                  TFun ("s", [ TFun ("s", [ TFun ("zero", []) ]) ]);
> +                  TFun ("s", [ TFun ("s", [ TFun ("zero", []) ]) ])
> +                ] )
> +          ]))
>  
>  let fib2 () =
>    testInterpreter
> @@ -162,9 +178,11 @@ let fib2 () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "fib"
> -              , [ TFun ("s", [TFun ("s", [TFun ("zero", [])])])
> -                ; TFun ("s", [TFun ("zero", [])]) ] ) ]))
> +              ( "fib",
> +                [ TFun ("s", [ TFun ("s", [ TFun ("zero", []) ]) ]);
> +                  TFun ("s", [ TFun ("zero", []) ])
> +                ] )
> +          ]))
>  
>  let twoThree () =
>    testInterpreter
> @@ -175,18 +193,25 @@ let twoThree () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "add"
> -              , [ TFun ("s", [TFun ("s", [TFun ("zero", [])])])
> -                ; TFun ("s", [TFun ("s", [TFun ("s", [TFun ("zero", [])])])])
> -                ; TFun
> -                    ( "s"
> -                    , [ TFun
> -                          ( "s"
> -                          , [ TFun
> -                                ( "s"
> -                                , [ TFun
> -                                      ("s", [TFun ("s", [TFun ("zero", [])])])
> -                                  ] ) ] ) ] ) ] ) ]))
> +              ( "add",
> +                [ TFun ("s", [ TFun ("s", [ TFun ("zero", []) ]) ]);
> +                  TFun
> +                    ("s", [ TFun ("s", [ TFun ("s", [ TFun ("zero", []) ]) ]) ]);
> +                  TFun
> +                    ( "s",
> +                      [ TFun
> +                          ( "s",
> +                            [ TFun
> +                                ( "s",
> +                                  [ TFun
> +                                      ( "s",
> +                                        [ TFun ("s", [ TFun ("zero", []) ]) ]
> +                                      )
> +                                  ] )
> +                            ] )
> +                      ] )
> +                ] )
> +          ]))
>  
>  let addOneP () =
>    testInterpreter
> @@ -198,7 +223,8 @@ let addOneP () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ("addOne", [TFun ("zero", []); TFun ("s", [TFun ("zero", [])])])
> +              ( "addOne",
> +                [ TFun ("zero", []); TFun ("s", [ TFun ("zero", []) ]) ] )
>            ]))
>  
>  let fib4 () =
> @@ -213,14 +239,18 @@ let fib4 () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "fib"
> -              , [ TFun
> -                    ( "s"
> -                    , [ TFun
> -                          ("s", [TFun ("s", [TFun ("s", [TFun ("zero", [])])])])
> -                      ] )
> -                ; TFun ("s", [TFun ("s", [TFun ("s", [TFun ("zero", [])])])])
> -                ] ) ]))
> +              ( "fib",
> +                [ TFun
> +                    ( "s",
> +                      [ TFun
> +                          ( "s",
> +                            [ TFun ("s", [ TFun ("s", [ TFun ("zero", []) ]) ])
> +                            ] )
> +                      ] );
> +                  TFun
> +                    ("s", [ TFun ("s", [ TFun ("s", [ TFun ("zero", []) ]) ]) ])
> +                ] )
> +          ]))
>  
>  let fib13 () =
>    testInterpreter
> @@ -234,63 +264,64 @@ let fib13 () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "fib"
> -              , [ TFun
> -                    ( "s"
> -                    , [ TFun
> -                          ( "s"
> -                          , [ TFun
> -                                ( "s"
> -                                , [ TFun
> -                                      ( "s"
> -                                      , [ TFun
> -                                            ( "s"
> -                                            , [ TFun
> -                                                  ( "s"
> -                                                  , [ TFun
> -                                                        ( "s"
> -                                                        , [TFun ("zero", [])]
> -                                                        ) ] ) ] ) ] ) ] ) ] )
> -                      ] )
> -                ; TFun
> -                    ( "s"
> -                    , [ TFun
> -                          ( "s"
> -                          , [ TFun
> -                                ( "s"
> -                                , [ TFun
> -                                      ( "s"
> -                                      , [ TFun
> -                                            ( "s"
> -                                            , [ TFun
> -                                                  ( "s"
> -                                                  , [ TFun
> -                                                        ( "s"
> -                                                        , [ TFun
> -                                                              ( "s"
> -                                                              , [ TFun
> -                                                                    ( "s"
> -                                                                    , [ TFun
> -                                                                          ( "s"
> -                                                                          , [ TFun
> +              ( "fib",
> +                [ TFun
> +                    ( "s",
> +                      [ TFun
> +                          ( "s",
> +                            [ TFun
> +                                ( "s",
> +                                  [ TFun
> +                                      ( "s",
> +                                        [ TFun
> +                                            ( "s",
> +                                              [ TFun
> +                                                  ( "s",
> +                                                    [ TFun
> +                                                        ( "s",
> +                                                          [ TFun ("zero", []) ]
> +                                                        )
> +                                                    ] )
> +                                              ] )
> +                                        ] )
> +                                  ] )
> +                            ] )
> +                      ] );
> +                  TFun
> +                    ( "s",
> +                      [ TFun
> +                          ( "s",
> +                            [ TFun
> +                                ( "s",
> +                                  [ TFun
> +                                      ( "s",
> +                                        [ TFun
> +                                            ( "s",
> +                                              [ TFun
> +                                                  ( "s",
> +                                                    [ TFun
> +                                                        ( "s",
> +                                                          [ TFun
> +                                                              ( "s",
> +                                                                [ TFun
> +                                                                    ( "s",
> +                                                                      [ TFun
> +                                                                          ( "s",
> +                                                                            [ TFun
>                                                                                 ( 
> -                                                                               "s"
> -                                                                               , 
> +                                                                               "s",
>                                                                                 [ 
>                                                                                 TFun
>                                                                                 ( 
> -                                                                               "s"
> -                                                                               , 
> +                                                                               "s",
>                                                                                 [ 
>                                                                                 TFun
>                                                                                 ( 
> -                                                                               "s"
> -                                                                               , 
> +                                                                               "s",
>                                                                                 [ 
>                                                                                 TFun
>                                                                                 ( 
> -                                                                               "zero"
> -                                                                               , 
> +                                                                               "zero",
>                                                                                 []
>                                                                                 )
>                                                                                 ]
> @@ -300,10 +331,18 @@ let fib13 () =
>                                                                                 ]
>                                                                                 )
>                                                                              ]
> -                                                                          ) ]
> -                                                                    ) ] ) ] )
> -                                                    ] ) ] ) ] ) ] ) ] ) ] ) ]
> -              ) ]))
> +                                                                          )
> +                                                                      ] )
> +                                                                ] )
> +                                                          ] )
> +                                                    ] )
> +                                              ] )
> +                                        ] )
> +                                  ] )
> +                            ] )
> +                      ] )
> +                ] )
> +          ]))
>  
>  let pairOne () =
>    testInterpreter
> @@ -317,10 +356,12 @@ let pairOne () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "less"
> -              , [ TFun ("pair", [TFun ("one", []); TFun ("null", [])])
> -                ; TFun ("two", [])
> -                ; TFun ("pair", [TFun ("one", []); TFun ("null", [])]) ] ) ]))
> +              ( "less",
> +                [ TFun ("pair", [ TFun ("one", []); TFun ("null", []) ]);
> +                  TFun ("two", []);
> +                  TFun ("pair", [ TFun ("one", []); TFun ("null", []) ])
> +                ] )
> +          ]))
>  
>  let quick21 () =
>    testInterpreter
> @@ -362,17 +403,19 @@ let quick21 () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "quick"
> -              , [ TFun
> -                    ( "pair"
> -                    , [ TFun ("two", [])
> -                      ; TFun ("pair", [TFun ("one", []); TFun ("null", [])]) ]
> -                    )
> -                ; TFun
> -                    ( "pair"
> -                    , [ TFun ("one", [])
> -                      ; TFun ("pair", [TFun ("two", []); TFun ("null", [])]) ]
> -                    ) ] ) ]))
> +              ( "quick",
> +                [ TFun
> +                    ( "pair",
> +                      [ TFun ("two", []);
> +                        TFun ("pair", [ TFun ("one", []); TFun ("null", []) ])
> +                      ] );
> +                  TFun
> +                    ( "pair",
> +                      [ TFun ("one", []);
> +                        TFun ("pair", [ TFun ("two", []); TFun ("null", []) ])
> +                      ] )
> +                ] )
> +          ]))
>  
>  let quick213 () =
>    testInterpreter
> @@ -413,22 +456,25 @@ let quick213 () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "quick"
> -              , [ TFun
> -                    ( "pair"
> -                    , [ TFun ("two", [])
> -                      ; TFun
> -                          ( "pair"
> -                          , [ TFun ("one", [])
> -                            ; TFun
> -                                ( "pair"
> -                                , [TFun ("three", []); TFun ("null", [])] ) ]
> -                          ) ] )
> -                ; TFun
> -                    ( "pair"
> -                    , [ TFun ("one", [])
> -                      ; TFun ("pair", [TFun ("two", []); TFun ("three", [])])
> -                      ] ) ] ) ]))
> +              ( "quick",
> +                [ TFun
> +                    ( "pair",
> +                      [ TFun ("two", []);
> +                        TFun
> +                          ( "pair",
> +                            [ TFun ("one", []);
> +                              TFun
> +                                ( "pair",
> +                                  [ TFun ("three", []); TFun ("null", []) ] )
> +                            ] )
> +                      ] );
> +                  TFun
> +                    ( "pair",
> +                      [ TFun ("one", []);
> +                        TFun ("pair", [ TFun ("two", []); TFun ("three", []) ])
> +                      ] )
> +                ] )
> +          ]))
>  
>  let sort21312 () =
>    testInterpreter
> @@ -470,69 +516,80 @@ let sort21312 () =
>      (Ans
>         (Resolvant
>            [ Atom
> -              ( "quick"
> -              , [ TFun
> -                    ( "pair"
> -                    , [ TFun ("two", [])
> -                      ; TFun
> -                          ( "pair"
> -                          , [ TFun ("one", [])
> -                            ; TFun
> -                                ( "pair"
> -                                , [ TFun ("three", [])
> -                                  ; TFun
> -                                      ( "pair"
> -                                      , [ TFun ("one", [])
> -                                        ; TFun
> -                                            ( "pair"
> -                                            , [ TFun ("two", [])
> -                                              ; TFun ("null", []) ] ) ] ) ] )
> -                            ] ) ] )
> -                ; TFun
> -                    ( "pair"
> -                    , [ TFun ("one", [])
> -                      ; TFun
> -                          ( "pair"
> -                          , [ TFun ("one", [])
> -                            ; TFun
> -                                ( "pair"
> -                                , [ TFun ("two", [])
> -                                  ; TFun
> -                                      ( "pair"
> -                                      , [ TFun ("two", [])
> -                                        ; TFun
> -                                            ( "pair"
> -                                            , [ TFun ("three", [])
> -                                              ; TFun ("null", []) ] ) ] ) ] )
> -                            ] ) ] ) ] ) ]))
> +              ( "quick",
> +                [ TFun
> +                    ( "pair",
> +                      [ TFun ("two", []);
> +                        TFun
> +                          ( "pair",
> +                            [ TFun ("one", []);
> +                              TFun
> +                                ( "pair",
> +                                  [ TFun ("three", []);
> +                                    TFun
> +                                      ( "pair",
> +                                        [ TFun ("one", []);
> +                                          TFun
> +                                            ( "pair",
> +                                              [ TFun ("two", []);
> +                                                TFun ("null", [])
> +                                              ] )
> +                                        ] )
> +                                  ] )
> +                            ] )
> +                      ] );
> +                  TFun
> +                    ( "pair",
> +                      [ TFun ("one", []);
> +                        TFun
> +                          ( "pair",
> +                            [ TFun ("one", []);
> +                              TFun
> +                                ( "pair",
> +                                  [ TFun ("two", []);
> +                                    TFun
> +                                      ( "pair",
> +                                        [ TFun ("two", []);
> +                                          TFun
> +                                            ( "pair",
> +                                              [ TFun ("three", []);
> +                                                TFun ("null", [])
> +                                              ] )
> +                                        ] )
> +                                  ] )
> +                            ] )
> +                      ] )
> +                ] )
> +          ]))
>  
>  let suite =
>    "OUnit Lexer + Parser Tests"
> -  >::: [ "basic_true" >:: basic_true
> -       ; "basic_false" >:: basic_false
> -       ; "unification" >:: unification
> -       ; "basic_backtrack" >:: basic_backtrack
> -       ; "repeat_var" >:: repeat_var
> -       ; "two_var" >:: two_var
> -       ; "false_1" >:: false_1
> -       ; "priority_order" >:: priority_order
> -       ; "t9" >:: t9
> -       ; "no_swaps" >:: no_swaps
> -       ; "swaps1" >:: swaps1
> -       ; "swaps2" >:: swaps2
> -       ; "structarg" >:: structarg
> -       ; "addOne" >:: addOne
> -       ; "onePlusOne" >:: onePlusOne
> -       ; "alpha1" >:: alpha1
> -       ; "alpha2" >:: alpha2
> -       ; "alpha3" >:: alpha3
> -       ; "zeroTwo" >:: zeroTwo
> -       ; "addOneP" >:: addOneP
> -       ; "fib4" >:: fib4
> -       ; "fib13" >:: fib13
> -       ; "pairOne" >:: pairOne
> -       ; "quick21" >:: quick21
> -       ; "quick213" >:: quick213
> -       ; "sort21312" >:: sort21312 ]
> +  >::: [ "basic_true" >:: basic_true;
> +         "basic_false" >:: basic_false;
> +         "unification" >:: unification;
> +         "basic_backtrack" >:: basic_backtrack;
> +         "repeat_var" >:: repeat_var;
> +         "two_var" >:: two_var;
> +         "false_1" >:: false_1;
> +         "priority_order" >:: priority_order;
> +         "t9" >:: t9;
> +         "no_swaps" >:: no_swaps;
> +         "swaps1" >:: swaps1;
> +         "swaps2" >:: swaps2;
> +         "structarg" >:: structarg;
> +         "addOne" >:: addOne;
> +         "onePlusOne" >:: onePlusOne;
> +         "alpha1" >:: alpha1;
> +         "alpha2" >:: alpha2;
> +         "alpha3" >:: alpha3;
> +         "zeroTwo" >:: zeroTwo;
> +         "addOneP" >:: addOneP;
> +         "fib4" >:: fib4;
> +         "fib13" >:: fib13;
> +         "pairOne" >:: pairOne;
> +         "quick21" >:: quick21;
> +         "quick213" >:: quick213;
> +         "sort21312" >:: sort21312
> +       ]
>  
>  let _ = run_test_tt_main suite
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/prolog_lexer_parser/parser.ml) > _build/default/src/interpreter/prolog_lexer_parser/.formatted/parser.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/test/useMachine1.ml) > _build/default/src/interpreter/test/.formatted/useMachine1.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/interpreter/test/parserTest.ml) > _build/default/src/interpreter/test/.formatted/parserTest.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/prolog_lexer_parser/parser.ml src/interpreter/prolog_lexer_parser/.formatted/parser.ml)
> diff --git a/src/interpreter/prolog_lexer_parser/parser.ml b/src/interpreter/prolog_lexer_parser/.formatted/parser.ml
> index 88574e4..047bf95 100644
> --- a/src/interpreter/prolog_lexer_parser/parser.ml
> +++ b/src/interpreter/prolog_lexer_parser/.formatted/parser.ml
> @@ -17,11 +17,12 @@ include MenhirBasics
>  
>  let _eRR = MenhirBasics.Error
>  
> -type _menhir_env =
> -  { _menhir_lexer: Lexing.lexbuf -> token
> -  ; _menhir_lexbuf: Lexing.lexbuf
> -  ; _menhir_token: token
> -  ; mutable _menhir_error: bool }
> +type _menhir_env = {
> +  _menhir_lexer : Lexing.lexbuf -> token;
> +  _menhir_lexbuf : Lexing.lexbuf;
> +  _menhir_token : token;
> +  mutable _menhir_error : bool;
> +}
>  
>  and _menhir_state =
>    | MenhirState29
> @@ -46,7 +47,7 @@ let rec _menhir_goto_sentence :
>        let (_menhir_stack : 'freshtv133 * _menhir_state * 'tv_sentence) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | QUES ->
> @@ -61,8 +62,8 @@ let rec _menhir_goto_sentence :
>                    _menhir_run2 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState20 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState20
>                : 'freshtv128 )
> @@ -78,8 +79,8 @@ let rec _menhir_goto_sentence :
>                _menhir_goto_program _menhir_env _menhir_stack _menhir_s _v
>                : 'freshtv130 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack : 'freshtv131 * _menhir_state * 'tv_sentence) =
>                Obj.magic _menhir_stack
> @@ -103,9 +104,9 @@ let rec _menhir_goto_sentence :
>                  * 'tv_sentence) =
>            Obj.magic _menhir_stack
>          in
> -        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_clause))
> -              , _
> -              , (_2 : 'tv_sentence) ) =
> +        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_clause)),
> +                _,
> +                (_2 : 'tv_sentence) ) =
>              _menhir_stack
>            in
>            let _v : 'tv_sentence = addClause _2 _1 in
> @@ -122,7 +123,7 @@ and _menhir_goto_program :
>    let (_menhir_stack : 'freshtv125 * _menhir_state * 'tv_program) =
>      Obj.magic _menhir_stack
>    in
> -  ( assert (not _menhir_env._menhir_error) ;
> +  ( assert (not _menhir_env._menhir_error);
>      let _tok = _menhir_env._menhir_token in
>      match _tok with
>      | END ->
> @@ -158,8 +159,8 @@ and _menhir_goto_program :
>              : 'freshtv120 )
>            : 'freshtv122 )
>      | _ ->
> -        assert (not _menhir_env._menhir_error) ;
> -        _menhir_env._menhir_error <- true ;
> +        assert (not _menhir_env._menhir_error);
> +        _menhir_env._menhir_error <- true;
>          let (_menhir_env : _menhir_env) = _menhir_env in
>          let (_menhir_stack : 'freshtv123 * _menhir_state * 'tv_program) =
>            Obj.magic _menhir_stack
> @@ -182,7 +183,7 @@ and _menhir_goto_term_list :
>                * 'tv_term_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | RBRAC ->
> @@ -201,9 +202,9 @@ and _menhir_goto_term_list :
>                        * 'tv_term_list) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( (_menhir_stack, _menhir_s, (_1 : string))
> -                    , _
> -                    , (_3 : 'tv_term_list) ) =
> +              ( let ( (_menhir_stack, _menhir_s, (_1 : string)),
> +                      _,
> +                      (_3 : 'tv_term_list) ) =
>                    _menhir_stack
>                  in
>                  let _4 = () in
> @@ -213,8 +214,8 @@ and _menhir_goto_term_list :
>                  : 'freshtv94 )
>                : 'freshtv96 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ('freshtv97 * _menhir_state * string)
> @@ -241,9 +242,9 @@ and _menhir_goto_term_list :
>                  * 'tv_term_list) =
>            Obj.magic _menhir_stack
>          in
> -        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_term))
> -              , _
> -              , (_3 : 'tv_term_list) ) =
> +        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_term)),
> +                _,
> +                (_3 : 'tv_term_list) ) =
>              _menhir_stack
>            in
>            let _2 = () in
> @@ -259,7 +260,7 @@ and _menhir_goto_term_list :
>                * 'tv_term_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | RBRAC ->
> @@ -278,9 +279,9 @@ and _menhir_goto_term_list :
>                        * 'tv_term_list) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( (_menhir_stack, _menhir_s, (_1 : string))
> -                    , _
> -                    , (_3 : 'tv_term_list) ) =
> +              ( let ( (_menhir_stack, _menhir_s, (_1 : string)),
> +                      _,
> +                      (_3 : 'tv_term_list) ) =
>                    _menhir_stack
>                  in
>                  let _4 = () in
> @@ -290,8 +291,8 @@ and _menhir_goto_term_list :
>                  : 'freshtv106 )
>                : 'freshtv108 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ('freshtv109 * _menhir_state * string)
> @@ -308,7 +309,7 @@ and _menhir_goto_term_list :
>  and _menhir_fail : unit -> 'a =
>   fun () ->
>    Printf.fprintf Pervasives.stderr
> -    "Internal failure -- please contact the parser generator's developers.\n%!" ;
> +    "Internal failure -- please contact the parser generator's developers.\n%!";
>    assert false
>  
>  and _menhir_goto_clause :
> @@ -319,7 +320,7 @@ and _menhir_goto_clause :
>    let (_menhir_stack : 'freshtv91 * _menhir_state * 'tv_clause) =
>      Obj.magic _menhir_stack
>    in
> -  ( assert (not _menhir_env._menhir_error) ;
> +  ( assert (not _menhir_env._menhir_error);
>      let _tok = _menhir_env._menhir_token in
>      match _tok with
>      | NAME _v ->
> @@ -330,12 +331,12 @@ and _menhir_goto_clause :
>            Obj.magic _menhir_stack
>          in
>          ( let _menhir_stack, _menhir_s, (_1 : 'tv_clause) = _menhir_stack in
> -          let _v : 'tv_sentence = Sentence [_1] in
> +          let _v : 'tv_sentence = Sentence [ _1 ] in
>            _menhir_goto_sentence _menhir_env _menhir_stack _menhir_s _v
>            : 'freshtv90 )
>      | _ ->
> -        assert (not _menhir_env._menhir_error) ;
> -        _menhir_env._menhir_error <- true ;
> +        assert (not _menhir_env._menhir_error);
> +        _menhir_env._menhir_error <- true;
>          _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState25
>      : 'freshtv92 )
>  
> @@ -371,7 +372,7 @@ and _menhir_goto_atom_list :
>                    let (_menhir_stack : 'freshtv63 * _menhir_state) =
>                      Obj.magic _menhir_stack
>                    in
> -                  let _ : _menhir_state = _menhir_s in
> +                  let (_ : _menhir_state) = _menhir_s in
>                    let ((_2 : 'tv_resolvant) : 'tv_resolvant) = _v in
>                    ( let _menhir_stack, _menhir_s = _menhir_stack in
>                      let _1 = () in
> @@ -392,7 +393,7 @@ and _menhir_goto_atom_list :
>                          : 'freshtv67 * _menhir_state * 'tv_sentence) =
>                      Obj.magic _menhir_stack
>                    in
> -                  let _ : _menhir_state = _menhir_s in
> +                  let (_ : _menhir_state) = _menhir_s in
>                    let ((_3 : 'tv_resolvant) : 'tv_resolvant) = _v in
>                    ( let _menhir_stack, _menhir_s, (_1 : 'tv_sentence) =
>                        _menhir_stack
> @@ -421,9 +422,9 @@ and _menhir_goto_atom_list :
>                  * 'tv_atom_list) =
>            Obj.magic _menhir_stack
>          in
> -        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_atom))
> -              , _
> -              , (_3 : 'tv_atom_list) ) =
> +        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_atom)),
> +                _,
> +                (_3 : 'tv_atom_list) ) =
>              _menhir_stack
>            in
>            let _2 = () in
> @@ -439,7 +440,7 @@ and _menhir_goto_atom_list :
>                * 'tv_atom_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | FSTOP ->
> @@ -458,9 +459,9 @@ and _menhir_goto_atom_list :
>                        * 'tv_atom_list) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_atom))
> -                    , _
> -                    , (_3 : 'tv_atom_list) ) =
> +              ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_atom)),
> +                      _,
> +                      (_3 : 'tv_atom_list) ) =
>                    _menhir_stack
>                  in
>                  let _4 = () in
> @@ -470,8 +471,8 @@ and _menhir_goto_atom_list :
>                  : 'freshtv82 )
>                : 'freshtv84 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ('freshtv85 * _menhir_state * 'tv_atom)
> @@ -493,7 +494,7 @@ and _menhir_goto_term :
>    let (_menhir_stack : 'freshtv61 * _menhir_state * 'tv_term) =
>      Obj.magic _menhir_stack
>    in
> -  ( assert (not _menhir_env._menhir_error) ;
> +  ( assert (not _menhir_env._menhir_error);
>      let _tok = _menhir_env._menhir_token in
>      match _tok with
>      | COMMA ->
> @@ -511,8 +512,8 @@ and _menhir_goto_term :
>                _menhir_run4 _menhir_env (Obj.magic _menhir_stack) MenhirState10
>                  _v
>            | _ ->
> -              assert (not _menhir_env._menhir_error) ;
> -              _menhir_env._menhir_error <- true ;
> +              assert (not _menhir_env._menhir_error);
> +              _menhir_env._menhir_error <- true;
>                _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                  MenhirState10
>            : 'freshtv56 )
> @@ -522,12 +523,12 @@ and _menhir_goto_term :
>            Obj.magic _menhir_stack
>          in
>          ( let _menhir_stack, _menhir_s, (_1 : 'tv_term) = _menhir_stack in
> -          let _v : 'tv_term_list = [_1] in
> +          let _v : 'tv_term_list = [ _1 ] in
>            _menhir_goto_term_list _menhir_env _menhir_stack _menhir_s _v
>            : 'freshtv58 )
>      | _ ->
> -        assert (not _menhir_env._menhir_error) ;
> -        _menhir_env._menhir_error <- true ;
> +        assert (not _menhir_env._menhir_error);
> +        _menhir_env._menhir_error <- true;
>          let (_menhir_env : _menhir_env) = _menhir_env in
>          let (_menhir_stack : 'freshtv59 * _menhir_state * 'tv_term) =
>            Obj.magic _menhir_stack
> @@ -547,7 +548,7 @@ and _menhir_goto_atom :
>        let (_menhir_stack : 'freshtv43 * _menhir_state * 'tv_atom) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | COMMA ->
> @@ -562,8 +563,8 @@ and _menhir_goto_atom :
>                    _menhir_run2 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState17 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState17
>                : 'freshtv38 )
> @@ -573,12 +574,12 @@ and _menhir_goto_atom :
>                Obj.magic _menhir_stack
>              in
>              ( let _menhir_stack, _menhir_s, (_1 : 'tv_atom) = _menhir_stack in
> -              let _v : 'tv_atom_list = [_1] in
> +              let _v : 'tv_atom_list = [ _1 ] in
>                _menhir_goto_atom_list _menhir_env _menhir_stack _menhir_s _v
>                : 'freshtv40 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack : 'freshtv41 * _menhir_state * 'tv_atom) =
>                Obj.magic _menhir_stack
> @@ -592,7 +593,7 @@ and _menhir_goto_atom :
>        let (_menhir_stack : 'freshtv53 * _menhir_state * 'tv_atom) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | ARR ->
> @@ -607,8 +608,8 @@ and _menhir_goto_atom :
>                    _menhir_run2 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState29 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState29
>                : 'freshtv46 )
> @@ -629,8 +630,8 @@ and _menhir_goto_atom :
>                  : 'freshtv48 )
>                : 'freshtv50 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack : 'freshtv51 * _menhir_state * 'tv_atom) =
>                Obj.magic _menhir_stack
> @@ -673,8 +674,8 @@ and _menhir_run5 :
>          | VAR _v ->
>              _menhir_run4 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                MenhirState6
>          : 'freshtv30 )
> @@ -688,8 +689,8 @@ and _menhir_run5 :
>          _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v
>          : 'freshtv32 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv33 * _menhir_state * string) =
>          Obj.magic _menhir_stack
> @@ -791,8 +792,8 @@ and _menhir_run2 :
>          | VAR _v ->
>              _menhir_run4 _menhir_env (Obj.magic _menhir_stack) MenhirState3 _v
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                MenhirState3
>          : 'freshtv6 )
> @@ -806,8 +807,8 @@ and _menhir_run2 :
>          _menhir_goto_atom _menhir_env _menhir_stack _menhir_s _v
>          : 'freshtv8 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv9 * _menhir_state * string) =
>          Obj.magic _menhir_stack
> @@ -821,10 +822,12 @@ and _menhir_discard : _menhir_env -> _menhir_env =
>    let lexer = _menhir_env._menhir_lexer in
>    let lexbuf = _menhir_env._menhir_lexbuf in
>    let _tok = lexer lexbuf in
> -  { _menhir_lexer= lexer
> -  ; _menhir_lexbuf= lexbuf
> -  ; _menhir_token= _tok
> -  ; _menhir_error= false }
> +  {
> +    _menhir_lexer = lexer;
> +    _menhir_lexbuf = lexbuf;
> +    _menhir_token = _tok;
> +    _menhir_error = false;
> +  }
>  
>  and main :
>      (Lexing.lexbuf -> token) -> Lexing.lexbuf -> string ParseTree.program =
> @@ -833,10 +836,12 @@ and main :
>      let (lexer : Lexing.lexbuf -> token) = lexer in
>      let (lexbuf : Lexing.lexbuf) = lexbuf in
>      ( let _tok = Obj.magic () in
> -      { _menhir_lexer= lexer
> -      ; _menhir_lexbuf= lexbuf
> -      ; _menhir_token= _tok
> -      ; _menhir_error= false }
> +      {
> +        _menhir_lexer = lexer;
> +        _menhir_lexbuf = lexbuf;
> +        _menhir_token = _tok;
> +        _menhir_error = false;
> +      }
>        : _menhir_env )
>    in
>    Obj.magic
> @@ -861,13 +866,13 @@ and main :
>                   _menhir_run2 _menhir_env (Obj.magic _menhir_stack)
>                     MenhirState1 _v
>               | _ ->
> -                 assert (not _menhir_env._menhir_error) ;
> -                 _menhir_env._menhir_error <- true ;
> +                 assert (not _menhir_env._menhir_error);
> +                 _menhir_env._menhir_error <- true;
>                   _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                     MenhirState1
>               : 'freshtv2 )
>         | _ ->
> -           assert (not _menhir_env._menhir_error) ;
> -           _menhir_env._menhir_error <- true ;
> +           assert (not _menhir_env._menhir_error);
> +           _menhir_env._menhir_error <- true;
>             _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState0
>         : 'freshtv4 ))
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/test/parserTest.ml src/interpreter/test/.formatted/parserTest.ml)
> diff --git a/src/interpreter/test/parserTest.ml b/src/interpreter/test/.formatted/parserTest.ml
> index c0897d0..61fa6bf 100644
> --- a/src/interpreter/test/parserTest.ml
> +++ b/src/interpreter/test/.formatted/parserTest.ml
> @@ -10,31 +10,37 @@ let basic_test () =
>    testLexerParser "animal(C):-cat(C)."
>      (Program
>         ( Sentence
> -           [Clause (Atom ("animal", [TVar "C"]), [Atom ("cat", [TVar "C"])])]
> -       , Resolvant [] ))
> +           [ Clause
> +               (Atom ("animal", [ TVar "C" ]), [ Atom ("cat", [ TVar "C" ]) ])
> +           ],
> +         Resolvant [] ))
>  
>  let no_body_test () =
>    testLexerParser "?-cat(C)"
> -    (Program (Sentence [], Resolvant [Atom ("cat", [TVar "C"])]))
> +    (Program (Sentence [], Resolvant [ Atom ("cat", [ TVar "C" ]) ]))
>  
>  let functor_test () =
>    testLexerParser "inStorePair(X,Y):-inStore(pair(X,Y))."
>      (Program
>         ( Sentence
>             [ Clause
> -               ( Atom ("inStorePair", [TVar "X"; TVar "Y"])
> -               , [Atom ("inStore", [TFun ("pair", [TVar "X"; TVar "Y"])])] ) ]
> -       , Resolvant [] ))
> +               ( Atom ("inStorePair", [ TVar "X"; TVar "Y" ]),
> +                 [ Atom ("inStore", [ TFun ("pair", [ TVar "X"; TVar "Y" ]) ]) ]
> +               )
> +           ],
> +         Resolvant [] ))
>  
>  let multi_clause_test () =
>    testLexerParser "fluffy(X) :- cat(X).\n     animal(X) :- cat(x)."
>      (Program
>         ( Sentence
> -           [ Clause (Atom ("fluffy", [TVar "X"]), [Atom ("cat", [TVar "X"])])
> -           ; Clause
> -               (Atom ("animal", [TVar "X"]), [Atom ("cat", [TFun ("x", [])])])
> -           ]
> -       , Resolvant [] ))
> +           [ Clause
> +               (Atom ("fluffy", [ TVar "X" ]), [ Atom ("cat", [ TVar "X" ]) ]);
> +             Clause
> +               ( Atom ("animal", [ TVar "X" ]),
> +                 [ Atom ("cat", [ TFun ("x", []) ]) ] )
> +           ],
> +         Resolvant [] ))
>  
>  let multi_resolvant_test () =
>    testLexerParser
> @@ -43,16 +49,19 @@ let multi_resolvant_test () =
>      (Program
>         ( Sentence
>             [ Clause
> -               ( Atom ("fluffy", [TVar "X"])
> -               , [ Atom ("cat", [TVar "X"])
> -                 ; Atom ("animal", [TFun ("build", [TVar "X"])]) ] ) ]
> -       , Resolvant
> -           [ Atom ("doggie", [TVar "X"])
> -           ; Atom ("bigAnimal", [TFun ("build", [TVar "X"])]) ] ))
> +               ( Atom ("fluffy", [ TVar "X" ]),
> +                 [ Atom ("cat", [ TVar "X" ]);
> +                   Atom ("animal", [ TFun ("build", [ TVar "X" ]) ])
> +                 ] )
> +           ],
> +         Resolvant
> +           [ Atom ("doggie", [ TVar "X" ]);
> +             Atom ("bigAnimal", [ TFun ("build", [ TVar "X" ]) ])
> +           ] ))
>  
>  let zero_term_in_pred_test () =
>    testLexerParser "cat."
> -    (Program (Sentence [Clause (Atom ("cat", []), [])], Resolvant []))
> +    (Program (Sentence [ Clause (Atom ("cat", []), []) ], Resolvant []))
>  
>  let many_term_in_pred_test () =
>    testLexerParser "cat(A, B, Variablename, VVVVV)."
> @@ -60,28 +69,33 @@ let many_term_in_pred_test () =
>         ( Sentence
>             [ Clause
>                 ( Atom
> -                   ( "cat"
> -                   , [TVar "A"; TVar "B"; TVar "Variablename"; TVar "VVVVV"] )
> -               , [] ) ]
> -       , Resolvant [] ))
> +                   ( "cat",
> +                     [ TVar "A"; TVar "B"; TVar "Variablename"; TVar "VVVVV" ]
> +                   ),
> +                 [] )
> +           ],
> +         Resolvant [] ))
>  
>  let atom_only_functor () =
>    testLexerParser
>      "\n  animal(X) :- cat(X).\n  cat(fluffy).\n\n  ?- animal(fluffy)\n  "
>      (Program
>         ( Sentence
> -           [ Clause (Atom ("animal", [TVar "X"]), [Atom ("cat", [TVar "X"])])
> -           ; Clause (Atom ("cat", [TFun ("fluffy", [])]), []) ]
> -       , Resolvant [Atom ("animal", [TFun ("fluffy", [])])] ))
> +           [ Clause
> +               (Atom ("animal", [ TVar "X" ]), [ Atom ("cat", [ TVar "X" ]) ]);
> +             Clause (Atom ("cat", [ TFun ("fluffy", []) ]), [])
> +           ],
> +         Resolvant [ Atom ("animal", [ TFun ("fluffy", []) ]) ] ))
>  
>  let suite =
>    "OUnit Lexer + Parser Tests"
> -  >::: [ "basic_test" >:: basic_test
> -       ; "no_body_test" >:: no_body_test
> -       ; "functor_test" >:: functor_test
> -       ; "multi_clause_test" >:: multi_clause_test
> -       ; "multi_resolvant_test" >:: multi_resolvant_test
> -       ; "zero_term_in_pred_test" >:: zero_term_in_pred_test
> -       ; "many_term_in_pred_test" >:: many_term_in_pred_test ]
> +  >::: [ "basic_test" >:: basic_test;
> +         "no_body_test" >:: no_body_test;
> +         "functor_test" >:: functor_test;
> +         "multi_clause_test" >:: multi_clause_test;
> +         "multi_resolvant_test" >:: multi_resolvant_test;
> +         "zero_term_in_pred_test" >:: zero_term_in_pred_test;
> +         "many_term_in_pred_test" >:: many_term_in_pred_test
> +       ]
>  
>  let _ = run_test_tt_main suite
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/interpreter/test/useMachine1.ml src/interpreter/test/.formatted/useMachine1.ml)
> diff --git a/src/interpreter/test/useMachine1.ml b/src/interpreter/test/.formatted/useMachine1.ml
> index d0f5ff3..9db180b 100644
> --- a/src/interpreter/test/useMachine1.ml
> +++ b/src/interpreter/test/.formatted/useMachine1.ml
> @@ -37,8 +37,8 @@ let test_case =
>     ?- quick(pair(two,pair(one,null)),X)\n\n"
>  
>  let () =
> -  Printf.printf "Machine 1\n" ;
> -  print_endline "\n" ;
> +  Printf.printf "Machine 1\n";
> +  print_endline "\n";
>    let lexbuf = Lexing.from_string test_case in
>    let parseTree = Parser.main Lexer.token lexbuf in
>    let result = interpret parseTree in
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --intf src/lexer_parser/parser.mli) > _build/default/src/lexer_parser/.formatted/parser.mli
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/lexer_parser/lexer.ml) > _build/default/src/lexer_parser/.formatted/lexer.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/lexer_parser/lexer.ml src/lexer_parser/.formatted/lexer.ml)
> diff --git a/src/lexer_parser/lexer.ml b/src/lexer_parser/.formatted/lexer.ml
> index f9bccc2..4e38dad 100644
> --- a/src/lexer_parser/lexer.ml
> +++ b/src/lexer_parser/.formatted/lexer.ml
> @@ -3,22 +3,24 @@ open Parser
>  (* The type token is defined in parser.mli *)
>  
>  let __ocaml_lex_tables =
> -  { Lexing.lex_base=
> -      "\000\000\075\000\085\000\160\000\239\255\002\000\002\000\242\255\243\255\014\000\245\255\246\255\247\255\248\255\249\255\250\255\235\000\054\001\129\001\204\001\023\002\098\002\173\002\248\002\067\003\142\003\217\003\036\004\111\004\186\004\005\005\080\005\244\255\241\255"
> -  ; Lexing.lex_backtrk=
> -      "\255\255\019\000\018\000\017\000\255\255\015\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\017\000\017\000\017\000\017\000\017\000\000\000\004\000\017\000\017\000\001\000\017\000\017\000\002\000\017\000\017\000\003\000\255\255\255\255"
> -  ; Lexing.lex_default=
> -      "\255\255\255\255\255\255\255\255\000\000\255\255\255\255\000\000\000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000"
> -  ; Lexing.lex_trans=
> -      "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\005\000\005\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\010\000\005\000\000\000\000\000\000\000\000\000\000\000\014\000\013\000\000\000\008\000\011\000\004\000\007\000\033\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\009\000\032\000\000\000\015\000\000\000\006\000\000\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\018\000\003\000\003\000\019\000\003\000\003\000\003\000\003\000\003\000\003\000\016\000\003\000\003\000\003\000\017\000\003\000\003\000\003\000\003\000\003\000\003\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\012\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\029\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\026\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\023\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\020\000\003\000\003\000\003\000\003\000\021\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\022\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\024\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\025\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\027\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\028\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\030\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\031\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
> -  ; Lexing.lex_check=
> -      "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\005\000\005\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\005\000\255\255\255\255\255\255\255\255\255\255\000\000\000\000\255\255\000\000\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\255\255\000\000\255\255\000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\255\255\255\255\255\255\255\255\255\255\255\255\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\255\255\255\255\255\255\255\255\255\255\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\255\255\255\255\255\255\255\255\255\255\255\255\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\255\255\255\255\255\255\255\255\255\255\255\255\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\255\255\255\255\255\255\255\255\255\255\255\255\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\255\255\255\255\255\255\255\255\255\255\255\255\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\255\255\255\255\255\255\255\255\255\255\255\255\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\255\255\255\255\255\255\255\255\255\255\255\255\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\255\255\255\255\255\255\255\255\255\255\255\255\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\255\255\255\255\255\255\255\255\255\255\255\255\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\255\255\255\255\255\255\255\255\255\255\255\255\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\255\255\255\255\255\255\255\255\255\255\255\255\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\255\255\255\255\255\255\255\255\255\255\255\255\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\255\255\255\255\255\255\255\255\255\255\255\255\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\255\255\255\255\255\255\255\255\255\255\255\255\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\255\255\255\255\255\255\255\255\255\255\255\255\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\255\255\255\255\255\255\255\255\255\255\255\255\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\255\255\255\255\255\255\255\255\255\255\255\255\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255"
> -  ; Lexing.lex_base_code= ""
> -  ; Lexing.lex_backtrk_code= ""
> -  ; Lexing.lex_default_code= ""
> -  ; Lexing.lex_trans_code= ""
> -  ; Lexing.lex_check_code= ""
> -  ; Lexing.lex_code= "" }
> +  {
> +    Lexing.lex_base =
> +      "\000\000\075\000\085\000\160\000\239\255\002\000\002\000\242\255\243\255\014\000\245\255\246\255\247\255\248\255\249\255\250\255\235\000\054\001\129\001\204\001\023\002\098\002\173\002\248\002\067\003\142\003\217\003\036\004\111\004\186\004\005\005\080\005\244\255\241\255";
> +    Lexing.lex_backtrk =
> +      "\255\255\019\000\018\000\017\000\255\255\015\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\017\000\017\000\017\000\017\000\017\000\000\000\004\000\017\000\017\000\001\000\017\000\017\000\002\000\017\000\017\000\003\000\255\255\255\255";
> +    Lexing.lex_default =
> +      "\255\255\255\255\255\255\255\255\000\000\255\255\255\255\000\000\000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000";
> +    Lexing.lex_trans =
> +      "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\005\000\005\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\010\000\005\000\000\000\000\000\000\000\000\000\000\000\014\000\013\000\000\000\008\000\011\000\004\000\007\000\033\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\009\000\032\000\000\000\015\000\000\000\006\000\000\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\018\000\003\000\003\000\019\000\003\000\003\000\003\000\003\000\003\000\003\000\016\000\003\000\003\000\003\000\017\000\003\000\003\000\003\000\003\000\003\000\003\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\012\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\029\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\026\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\023\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\020\000\003\000\003\000\003\000\003\000\021\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\022\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\024\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\025\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\027\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\028\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\030\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\031\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000";
> +    Lexing.lex_check =
> +      "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\005\000\005\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\005\000\255\255\255\255\255\255\255\255\255\255\000\000\000\000\255\255\000\000\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\255\255\000\000\255\255\000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\255\255\255\255\255\255\255\255\255\255\255\255\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\255\255\255\255\255\255\255\255\255\255\000\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\255\255\255\255\255\255\255\255\255\255\255\255\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\255\255\255\255\255\255\255\255\255\255\255\255\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\255\255\255\255\255\255\255\255\255\255\255\255\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\255\255\255\255\255\255\255\255\255\255\255\255\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\255\255\255\255\255\255\255\255\255\255\255\255\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\255\255\255\255\255\255\255\255\255\255\255\255\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\255\255\255\255\255\255\255\255\255\255\255\255\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\255\255\255\255\255\255\255\255\255\255\255\255\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\255\255\255\255\255\255\255\255\255\255\255\255\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\255\255\255\255\255\255\255\255\255\255\255\255\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\255\255\255\255\255\255\255\255\255\255\255\255\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\255\255\255\255\255\255\255\255\255\255\255\255\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\255\255\255\255\255\255\255\255\255\255\255\255\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\255\255\255\255\255\255\255\255\255\255\255\255\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\255\255\255\255\255\255\255\255\255\255\255\255\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\255\255\255\255\255\255\255\255\255\255\255\255\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255";
> +    Lexing.lex_base_code = "";
> +    Lexing.lex_backtrk_code = "";
> +    Lexing.lex_default_code = "";
> +    Lexing.lex_trans_code = "";
> +    Lexing.lex_check_code = "";
> +    Lexing.lex_code = "";
> +  }
>  
>  let rec token lexbuf = __ocaml_lex_token_rec lexbuf 0
>  
> @@ -60,5 +62,5 @@ and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
>        in
>        INT (int_of_string x)
>    | __ocaml_lex_state ->
> -      lexbuf.Lexing.refill_buff lexbuf ;
> +      lexbuf.Lexing.refill_buff lexbuf;
>        __ocaml_lex_token_rec lexbuf __ocaml_lex_state
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/lexer_parser/parseTree.ml) > _build/default/src/lexer_parser/.formatted/parseTree.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/run_project/executeFromFile.ml) > _build/default/src/run_project/.formatted/executeFromFile.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/run_project/executeFromFile.ml src/run_project/.formatted/executeFromFile.ml)
> diff --git a/src/run_project/executeFromFile.ml b/src/run_project/.formatted/executeFromFile.ml
> index 5c0cc86..f2fa0d3 100644
> --- a/src/run_project/executeFromFile.ml
> +++ b/src/run_project/.formatted/executeFromFile.ml
> @@ -5,7 +5,7 @@ open Logging
>  open RuntimeDataStructures
>  open FlattenInstrForPrint
>  
> -let getStructMap {nums= _; code= _; structMap= sm} = sm
> +let getStructMap { nums = _; code = _; structMap = sm } = sm
>  
>  type resFinal = variableFlat list [@@deriving show]
>  
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/run_project/runall.ml) > _build/default/src/run_project/.formatted/runall.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/run_project/writeInstrToFile.ml) > _build/default/src/run_project/.formatted/writeInstrToFile.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/run_project/runall.ml src/run_project/.formatted/runall.ml)
> diff --git a/src/run_project/runall.ml b/src/run_project/.formatted/runall.ml
> index b2f2d67..b11f908 100644
> --- a/src/run_project/runall.ml
> +++ b/src/run_project/.formatted/runall.ml
> @@ -26,14 +26,14 @@ let execute s tc =
>       in let () = print_endline str_query *)
>    in
>    let instr = genCode parseTree in
> -  let {code= flatcode; nums= arrLens; structMap= lookupmap} =
> +  let { code = flatcode; nums = arrLens; structMap = lookupmap } =
>      instr
>      (* in let str_code = Sexp.to_string(sexp_of_code (code,nums,st))
>       in let () = print_endline str_code  *)
> -    
> +
>      (* in let flatcode = lineariseCode code *)
>      (* in let () = logDebug (fun m -> m "%s" (strInstructionArray 0 flatcode)) *)
> -    
> +
>      (* in let instr = {code=flatcode; nums=nums; structMap = st} *)
>    in
>    let str_inst = Sexp.to_string (sexp_of_writtenInstr instr) in
> @@ -49,6 +49,8 @@ let execute s tc =
>          let str_res = Sexp.to_string (sexp_of_result res) in
>          let () = logInfo (fun m -> m "Result: %s" str_res) in
>          Some (List.map ~f:(flattenSv lookupmap) (Array.to_list res))
> -    | None -> print_endline "fail" ; None
> +    | None ->
> +        print_endline "fail";
> +        None
>    in
>    ans
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/run_project/writeInstrToFile.ml src/run_project/.formatted/writeInstrToFile.ml)
> diff --git a/src/run_project/writeInstrToFile.ml b/src/run_project/.formatted/writeInstrToFile.ml
> index 6357418..013845d 100644
> --- a/src/run_project/writeInstrToFile.ml
> +++ b/src/run_project/.formatted/writeInstrToFile.ml
> @@ -12,7 +12,7 @@ let writeInstructions location s tc =
>    in
>    let _typeinfo = typeCheck tc parseTree in
>    let instr = genCode parseTree in
> -  let {code= flatcode; nums= arrLens; structMap= lookupmap} = instr in
> +  let { code = flatcode; nums = arrLens; structMap = lookupmap } = instr in
>    let () = logInfo (fun m -> m "%s" (strInstructionArray 0 flatcode)) in
>    let toWrite =
>      instr
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/test_end_to_end/typeCheckTests.ml) > _build/default/src/test_end_to_end/.formatted/typeCheckTests.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/test_end_to_end/combineTests.ml) > _build/default/src/test_end_to_end/.formatted/combineTests.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/test_end_to_end/typeCheckTests.ml src/test_end_to_end/.formatted/typeCheckTests.ml)
> diff --git a/src/test_end_to_end/typeCheckTests.ml b/src/test_end_to_end/.formatted/typeCheckTests.ml
> index eec0a6e..f69d3b9 100644
> --- a/src/test_end_to_end/typeCheckTests.ml
> +++ b/src/test_end_to_end/.formatted/typeCheckTests.ml
> @@ -15,7 +15,7 @@ let simpleTypesPass () =
>       pred animal(cute).\n\n\
>       animal(dusk).\n\
>       ?- animal(X)\n"
> -    [Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
>  
>  (* let testMachineTc input_str expected_result =
>     assert_equal (execute input_str true) expected_result *)
> @@ -30,8 +30,9 @@ let typList () =
>       ?- addOne(nil,X)\n"
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "cons"
> -           , [|Dt.StrPointerF ("dusk", [||]); Dt.StrPointerF ("nil", [||])|] ))
> +           ( "cons",
> +             [| Dt.StrPointerF ("dusk", [||]); Dt.StrPointerF ("nil", [||]) |]
> +           ))
>      ]
>  
>  let simpleTypesFail () =
> @@ -137,12 +138,15 @@ let tcheckDfs () =
>       dfs(six,tree(zero,tree(one,tree(five,n,n),tree(six,n,n)),tree(two,tree(three,n,n),tree(four,n,n))),X)\n"
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "cons"
> -           , [| Dt.StrPointerF ("left", [||])
> -              ; Dt.StrPointerF
> -                  ( "cons"
> -                  , [| Dt.StrPointerF ("right", [||])
> -                     ; Dt.StrPointerF ("eol", [||]) |] ) |] )) ]
> +           ( "cons",
> +             [| Dt.StrPointerF ("left", [||]);
> +                Dt.StrPointerF
> +                  ( "cons",
> +                    [| Dt.StrPointerF ("right", [||]);
> +                       Dt.StrPointerF ("eol", [||])
> +                    |] )
> +             |] ))
> +    ]
>  
>  let tfail3 () =
>    try
> @@ -173,11 +177,11 @@ let noGeneralise () =
>          true
>      in
>      raise Oops
> -  
>    with
>    | Dt.Err
>        "Type mismatch expected type (ParseTree.TypeVar \"A\") saw struct dusk"
> -  -> ()
> +  ->
> +    ()
>  
>  let mustBeGeneral () =
>    try
> @@ -272,7 +276,7 @@ let useint () = testMachineTc "\npred addOne(int,int).\naddOne(X,Y).\n\n" []
>  let isexpr () =
>    testMachineTc
>      "\npred addOne(int,int).\naddOne(X,Y) :- Y is X + 1.\n\n?- addOne(2,Y)\n"
> -    [Dt.HeapPointerF (Dt.IntF 3)]
> +    [ Dt.HeapPointerF (Dt.IntF 3) ]
>  
>  let dfs_distinct () =
>    testMachineTc
> @@ -291,12 +295,15 @@ let dfs_distinct () =
>       dfs(six,node(zero,node(one,node(five,n,n),node(six,n,n)),node(two,node(three,n,n),node(four,n,n))),X)\n"
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "cons"
> -           , [| Dt.StrPointerF ("left", [||])
> -              ; Dt.StrPointerF
> -                  ( "cons"
> -                  , [| Dt.StrPointerF ("right", [||])
> -                     ; Dt.StrPointerF ("eol", [||]) |] ) |] )) ]
> +           ( "cons",
> +             [| Dt.StrPointerF ("left", [||]);
> +                Dt.StrPointerF
> +                  ( "cons",
> +                    [| Dt.StrPointerF ("right", [||]);
> +                       Dt.StrPointerF ("eol", [||])
> +                    |] )
> +             |] ))
> +    ]
>  
>  let isbig () =
>    testMachineTc
> @@ -305,7 +312,7 @@ let isbig () =
>       pred addOne(int,int).\n\
>       addOne(X,Y) :- Y is 1 - X + 1.\n\n\
>       ?- addOne(2,Y)\n"
> -    [Dt.HeapPointerF (Dt.IntF 0)]
> +    [ Dt.HeapPointerF (Dt.IntF 0) ]
>  
>  let trickt () =
>    try
> @@ -362,27 +369,28 @@ let neststruct2 () =
>      []
>  
>  let tests_tc =
> -  [ "simpleTypesPass" >:: simpleTypesPass
> -  ; "simpleTypesFail" >:: simpleTypesFail
> -  ; "typList" >:: typList
> -  ; "tfaillist" >:: tfaillist
> -  ; "addnugget" >:: addnugget
> -  ; "tfail1" >:: tfail1
> -  ; "tfail2" >:: tfail2
> -  ; "tcheckDfs" >:: tcheckDfs
> -  ; "tfail3" >:: tfail3
> -  ; "noGeneralise" >:: noGeneralise
> -  ; "mustBeGeneral" >:: mustBeGeneral
> -  ; "dogfail1" >:: dogfail1
> -  ; "unifystructfail" >:: unifystructfail
> -  ; "dogfail2" >:: dogfail2
> -  ; "notdef" >:: notdef
> -  ; "useint" >:: useint
> -  ; "isexpr" >:: isexpr
> -  ; "dfs_distinct" >:: dfs_distinct
> -  ; "isbig" >:: isbig
> -  ; "trickt" >:: trickt
> -  ; "intprob" >:: intprob
> -  ; "pass" >:: pass
> -  ; "nestrstruct" >:: nestrstruct
> -  ; "neststruct2" >:: neststruct2 ]
> +  [ "simpleTypesPass" >:: simpleTypesPass;
> +    "simpleTypesFail" >:: simpleTypesFail;
> +    "typList" >:: typList;
> +    "tfaillist" >:: tfaillist;
> +    "addnugget" >:: addnugget;
> +    "tfail1" >:: tfail1;
> +    "tfail2" >:: tfail2;
> +    "tcheckDfs" >:: tcheckDfs;
> +    "tfail3" >:: tfail3;
> +    "noGeneralise" >:: noGeneralise;
> +    "mustBeGeneral" >:: mustBeGeneral;
> +    "dogfail1" >:: dogfail1;
> +    "unifystructfail" >:: unifystructfail;
> +    "dogfail2" >:: dogfail2;
> +    "notdef" >:: notdef;
> +    "useint" >:: useint;
> +    "isexpr" >:: isexpr;
> +    "dfs_distinct" >:: dfs_distinct;
> +    "isbig" >:: isbig;
> +    "trickt" >:: trickt;
> +    "intprob" >:: intprob;
> +    "pass" >:: pass;
> +    "nestrstruct" >:: nestrstruct;
> +    "neststruct2" >:: neststruct2
> +  ]
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/typecheck/typeChecker.ml) > _build/default/src/typecheck/.formatted/typeChecker.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/typecheck/typeChecker.ml src/typecheck/.formatted/typeChecker.ml)
> diff --git a/src/typecheck/typeChecker.ml b/src/typecheck/.formatted/typeChecker.ml
> index cc6935d..448b3bc 100644
> --- a/src/typecheck/typeChecker.ml
> +++ b/src/typecheck/.formatted/typeChecker.ml
> @@ -8,10 +8,10 @@ open CheckClause
>  open CheckTypeEquivalence
>  
>  let logBindings binding =
> -  logDebug (fun m -> m "bindings are") ;
> +  logDebug (fun m -> m "bindings are");
>    Hashtbl.iteri
>      ~f:(fun ~key:k ~data:v ->
> -      logDebug (fun m -> m "(%a,%a)\n" pp_typei k pp_infv v) )
> +      logDebug (fun m -> m "(%a,%a)\n" pp_typei k pp_infv v))
>      binding
>  
>  type argtypelist = (var * intnum) typeins list [@@deriving show]
> @@ -19,7 +19,8 @@ type argtypelist = (var * intnum) typeins list [@@deriving show]
>  let typeCheckClause clause predTypes typeDefs constructorToType =
>    let (Clause (Atom (name, args), body)) = clause in
>    let () =
> -    logDebug (fun m -> m "TYPE CHECK CLAUSE: typeCheckClause %a \n" pp_var name)
> +    logDebug (fun m ->
> +        m "TYPE CHECK CLAUSE: typeCheckClause %a \n" pp_var name)
>    in
>    let () =
>      Hashtbl.iteri
> @@ -69,13 +70,13 @@ let checkPredTypesValid predTypes typeDefs =
>    let checkTypeInsAppears x =
>      match x with
>      | TypeCons (name, args) -> (
> -      match Hashtbl.find typeDefs name with
> -      | Some _ -> ()
> -      | None ->
> -          raise
> -            (Err
> -               ( "Could not find definition for " ^ name
> -               ^ show_intnum (List.length args) )) )
> +        match Hashtbl.find typeDefs name with
> +        | Some _ -> ()
> +        | None ->
> +            raise
> +              (Err
> +                 ( "Could not find definition for " ^ name
> +                 ^ show_intnum (List.length args) )) )
>      | TypeVar _ -> ()
>      | IntTyp -> ()
>    in
> @@ -88,16 +89,16 @@ let typeCheck tc (Program (Sentence body, Resolvant goals)) =
>    else (
>      (* let () = logDebug (fun m -> m "Program is  \n %a" (pp_program pp_var) (Program(Sentence(body),Resolvant(goals)))) *)
>      (* in  *)
> -    logInfo (fun m -> m "Type checker about to run\n") ;
> +    logInfo (fun m -> m "Type checker about to run\n");
>      let predTypes = getPredTypes body in
>      let typeDefs = getTypeDefs body in
>      let constructorToType = reverse typeDefs in
> -    checkPredTypesValid predTypes typeDefs ;
> +    checkPredTypesValid predTypes typeDefs;
>      List.iter
>        ~f:(fun x ->
>          match x with
>          | C x -> typeCheckClause x predTypes typeDefs constructorToType
> -        | _ -> () )
> -      body ;
> -    typeCheckQuery goals predTypes constructorToType ;
> +        | _ -> ())
> +      body;
> +    typeCheckQuery goals predTypes constructorToType;
>      logInfo (fun m -> m "Type checked sucessfully\n") )
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/test_end_to_end/noTypeCheck.ml) > _build/default/src/test_end_to_end/.formatted/noTypeCheck.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/test_end_to_end/noTypeCheck.ml src/test_end_to_end/.formatted/noTypeCheck.ml)
> diff --git a/src/test_end_to_end/noTypeCheck.ml b/src/test_end_to_end/.formatted/noTypeCheck.ml
> index 979b9e6..5a68a44 100644
> --- a/src/test_end_to_end/noTypeCheck.ml
> +++ b/src/test_end_to_end/.formatted/noTypeCheck.ml
> @@ -16,7 +16,7 @@ let test1 () =
>      \    nextTo(tree,tree).\n\
>      \    ?- nextTo(X,X)\n\
>      \    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("tree", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("tree", [||])) ]
>  
>  let test2 () =
>    testMachineNoTc
> @@ -24,7 +24,7 @@ let test2 () =
>  
>  let test3 () =
>    testMachineNoTc "\n    animal(dusk).\n    ?- animal(X)\n    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
>  
>  let test4 () =
>    testMachineNoTc
> @@ -33,18 +33,19 @@ let test4 () =
>      \    nextTo(tree,tree).\n\
>      \    ?- nextTo(X,X)\n\
>      \    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("tree", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("tree", [||])) ]
>  
>  let test5 () =
>    testMachineNoTc
>      "\n    animal(dusk).\n    animal(craig).\n    ?- animal(X)\n    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
>  
>  let test6 () =
>    testMachineNoTc
>      "\n   person(craig).\n   dog(dusk).\n   ?- person(X), dog(Y)\n   "
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("craig", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("craig", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> +    ]
>  
>  let backtrack () =
>    testMachineNoTc
> @@ -54,13 +55,14 @@ let backtrack () =
>      \    dog(dusk).\n\
>      \    ?- animal(X), dog(X)\n\
>      \    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
>  
>  let doubleVar () =
>    testMachineNoTc
>      "\n  person(craig).\n  dog(dusk).\n  ?- person(X), dog(Y)\n  "
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("craig", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("craig", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> +    ]
>  
>  let swaps1 () =
>    testMachineNoTc
> @@ -70,8 +72,9 @@ let swaps1 () =
>      \    f(X,Y) :- g(X), h(Y).\n\n\
>      \    ?-f(Y,X)\n\
>      \      "
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("craig", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("craig", [||]))
> +    ]
>  
>  let noSwaps () =
>    testMachineNoTc
> @@ -81,8 +84,9 @@ let noSwaps () =
>      \    f(A,B) :- g(A), h(B).\n\n\
>      \    ?-f(Y,X)\n\
>      \    "
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("craig", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("craig", [||]))
> +    ]
>  
>  let swaps2 () =
>    testMachineNoTc
> @@ -92,23 +96,25 @@ let swaps2 () =
>      \    f(X,Y) :- g(Y), h(X).\n\n\
>      \    ?-f(Y,X)\n\
>      \    "
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("craig", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("craig", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> +    ]
>  
>  let buildStruct1 () =
>    testMachineNoTc "\n  plant(flower(X)).\n\n  ?- plant(X)\n  "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("flower", [|Dt.UnboundVarF|]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("flower", [| Dt.UnboundVarF |])) ]
>  
>  let buildStruct2 () =
>    testMachineNoTc "\n    plant(flower(green(X))).\n\n    ?- plant(X)\n    "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ("flower", [|Dt.StrPointerF ("green", [|Dt.UnboundVarF|])|])) ]
> +           ("flower", [| Dt.StrPointerF ("green", [| Dt.UnboundVarF |]) |]))
> +    ]
>  
>  let nestedStructures () =
>    testMachineNoTc
>      "\n    g(dusk).\n    p(X,f(X)) :- g(X).\n    ?- p(X,f(X))\n    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
>  
>  let plus1 () =
>    testMachineNoTc
> @@ -117,7 +123,9 @@ let plus1 () =
>      \    add(X,s(Y),s(Z)) :- add(X,Y,Z).\n\
>      \    ?- add(zero,s(zero),X)\n\
>      \    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("s", [|Dt.StrPointerF ("zero", [||])|]))]
> +    [ Dt.HeapPointerF
> +        (Dt.StrPointerF ("s", [| Dt.StrPointerF ("zero", [||]) |]))
> +    ]
>  
>  let plus2 () =
>    testMachineNoTc
> @@ -128,23 +136,25 @@ let plus2 () =
>      \    "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ("s", [|Dt.StrPointerF ("s", [|Dt.StrPointerF ("zero", [||])|])|]))
> +           ( "s",
> +             [| Dt.StrPointerF ("s", [| Dt.StrPointerF ("zero", [||]) |]) |] ))
>      ]
>  
>  let inStruct () =
>    testMachineNoTc "\n    f(X).\n    ?- f(struct(X))\n    "
> -    [Dt.HeapPointerF Dt.UnboundVarF]
> +    [ Dt.HeapPointerF Dt.UnboundVarF ]
>  
>  let outStruct () =
>    testMachineNoTc "\n  f(struct(X)).\n\n  ?- f(X)\n  "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("struct", [|Dt.UnboundVarF|]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("struct", [| Dt.UnboundVarF |])) ]
>  
>  let alpha () =
>    testMachineNoTc
>      "\n    g(build(X)).\n    f(struct(X)) :- g(X).\n\n    ?- f(X)\n    "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ("struct", [|Dt.StrPointerF ("build", [|Dt.UnboundVarF|])|])) ]
> +           ("struct", [| Dt.StrPointerF ("build", [| Dt.UnboundVarF |]) |]))
> +    ]
>  
>  let zeroPLus2 () =
>    testMachineNoTc
> @@ -155,7 +165,8 @@ let zeroPLus2 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ("s", [|Dt.StrPointerF ("s", [|Dt.StrPointerF ("zero", [||])|])|]))
> +           ( "s",
> +             [| Dt.StrPointerF ("s", [| Dt.StrPointerF ("zero", [||]) |]) |] ))
>      ]
>  
>  let fib2 () =
> @@ -168,7 +179,9 @@ let fib2 () =
>      \    fib(s(s(X)),Y) :- fib(X,A), fib(s(X),B), add(A,B,Y).\n\n\
>      \    ?- fib(s(s(zero)),X)\n\n\
>      \    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("s", [|Dt.StrPointerF ("zero", [||])|]))]
> +    [ Dt.HeapPointerF
> +        (Dt.StrPointerF ("s", [| Dt.StrPointerF ("zero", [||]) |]))
> +    ]
>  
>  let twop3 () =
>    testMachineNoTc
> @@ -179,14 +192,17 @@ let twop3 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "s"
> -           , [| Dt.StrPointerF
> -                  ( "s"
> -                  , [| Dt.StrPointerF
> -                         ( "s"
> -                         , [| Dt.StrPointerF
> -                                ("s", [|Dt.StrPointerF ("zero", [||])|]) |] )
> -                    |] ) |] )) ]
> +           ( "s",
> +             [| Dt.StrPointerF
> +                  ( "s",
> +                    [| Dt.StrPointerF
> +                         ( "s",
> +                           [| Dt.StrPointerF
> +                                ("s", [| Dt.StrPointerF ("zero", [||]) |])
> +                           |] )
> +                    |] )
> +             |] ))
> +    ]
>  
>  let addOneFun () =
>    testMachineNoTc
> @@ -196,7 +212,9 @@ let addOneFun () =
>      \    addOne(X,Y) :- add(X,s(zero),A), add(A,zero,Y).\n\n\
>      \    ?- addOne(zero,A)\n\
>      \    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("s", [|Dt.StrPointerF ("zero", [||])|]))]
> +    [ Dt.HeapPointerF
> +        (Dt.StrPointerF ("s", [| Dt.StrPointerF ("zero", [||]) |]))
> +    ]
>  
>  let fib4 () =
>    testMachineNoTc
> @@ -210,11 +228,13 @@ let fib4 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "s"
> -           , [| Dt.StrPointerF
> -                  ( "s"
> -                  , [|Dt.StrPointerF ("s", [|Dt.StrPointerF ("zero", [||])|])|]
> -                  ) |] )) ]
> +           ( "s",
> +             [| Dt.StrPointerF
> +                  ( "s",
> +                    [| Dt.StrPointerF ("s", [| Dt.StrPointerF ("zero", [||]) |])
> +                    |] )
> +             |] ))
> +    ]
>  
>  let fib13 () =
>    testMachineNoTc
> @@ -228,49 +248,45 @@ let fib13 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "s"
> -           , [| Dt.StrPointerF
> -                  ( "s"
> -                  , [| Dt.StrPointerF
> -                         ( "s"
> -                         , [| Dt.StrPointerF
> -                                ( "s"
> -                                , [| Dt.StrPointerF
> -                                       ( "s"
> -                                       , [| Dt.StrPointerF
> -                                              ( "s"
> -                                              , [| Dt.StrPointerF
> -                                                     ( "s"
> -                                                     , [| Dt.StrPointerF
> -                                                            ( "s"
> -                                                            , [| Dt.StrPointerF
> -                                                                   ( "s"
> -                                                                   , [| Dt
> +           ( "s",
> +             [| Dt.StrPointerF
> +                  ( "s",
> +                    [| Dt.StrPointerF
> +                         ( "s",
> +                           [| Dt.StrPointerF
> +                                ( "s",
> +                                  [| Dt.StrPointerF
> +                                       ( "s",
> +                                         [| Dt.StrPointerF
> +                                              ( "s",
> +                                                [| Dt.StrPointerF
> +                                                     ( "s",
> +                                                       [| Dt.StrPointerF
> +                                                            ( "s",
> +                                                              [| Dt.StrPointerF
> +                                                                   ( "s",
> +                                                                     [| Dt
>                                                                          .StrPointerF
> -                                                                          ( "s"
> -                                                                          , [| Dt
> +                                                                          ( "s",
> +                                                                            [| Dt
>                                                                                 .StrPointerF
>                                                                                 ( 
> -                                                                               "s"
> -                                                                               , 
> +                                                                               "s",
>                                                                                 [| 
>                                                                                 Dt
>                                                                                 .StrPointerF
>                                                                                 ( 
> -                                                                               "s"
> -                                                                               , 
> +                                                                               "s",
>                                                                                 [| 
>                                                                                 Dt
>                                                                                 .StrPointerF
>                                                                                 ( 
> -                                                                               "s"
> -                                                                               , 
> +                                                                               "s",
>                                                                                 [| 
>                                                                                 Dt
>                                                                                 .StrPointerF
>                                                                                 ( 
> -                                                                               "zero"
> -                                                                               , 
> +                                                                               "zero",
>                                                                                 [| 
>                                                                                 |]
>                                                                                 )
> @@ -282,9 +298,16 @@ let fib13 () =
>                                                                                 )
>                                                                              |]
>                                                                            )
> -                                                                     |] ) |] )
> -                                                       |] ) |] ) |] ) |] ) |]
> -                         ) |] ) |] )) ]
> +                                                                     |] )
> +                                                              |] )
> +                                                       |] )
> +                                                |] )
> +                                         |] )
> +                                  |] )
> +                           |] )
> +                    |] )
> +             |] ))
> +    ]
>  
>  let pairOne () =
>    testMachineNoTc
> @@ -298,8 +321,9 @@ let pairOne () =
>      \      "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "pair"
> -           , [|Dt.StrPointerF ("one", [||]); Dt.StrPointerF ("null", [||])|] ))
> +           ( "pair",
> +             [| Dt.StrPointerF ("one", [||]); Dt.StrPointerF ("null", [||]) |]
> +           ))
>      ]
>  
>  let cyclicTest () =
> @@ -309,8 +333,9 @@ let cyclicTest () =
>      \    unif(X,X).\n\n\
>      \    ?-  unif(f(Y),f(X)), dog(X)\n\
>      \    "
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> +    ]
>  
>  let tripleBacktrack () =
>    testMachineNoTc
> @@ -321,7 +346,7 @@ let tripleBacktrack () =
>      \    dog(dusk).\n\n\
>      \    ?- animal(X), dog(X)\n\
>      \    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
>  
>  let geqTest () =
>    testMachineNoTc
> @@ -335,7 +360,7 @@ let geqTest () =
>      \     geq(pair(H,T), Bound, Result) :- ll(H, Bound), geq(T, Bound, Result).\n\n\
>      \    ?- geq(pair(one,pair(one,null)),two,Res)\n\
>      \    "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("null", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("null", [||])) ]
>  
>  let quick21 () =
>    testMachineNoTc
> @@ -376,12 +401,15 @@ let quick21 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "pair"
> -           , [| Dt.StrPointerF ("one", [||])
> -              ; Dt.StrPointerF
> -                  ( "pair"
> -                  , [| Dt.StrPointerF ("two", [||])
> -                     ; Dt.StrPointerF ("null", [||]) |] ) |] )) ]
> +           ( "pair",
> +             [| Dt.StrPointerF ("one", [||]);
> +                Dt.StrPointerF
> +                  ( "pair",
> +                    [| Dt.StrPointerF ("two", [||]);
> +                       Dt.StrPointerF ("null", [||])
> +                    |] )
> +             |] ))
> +    ]
>  
>  let quick213 () =
>    testMachineNoTc
> @@ -422,12 +450,15 @@ let quick213 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "pair"
> -           , [| Dt.StrPointerF ("one", [||])
> -              ; Dt.StrPointerF
> -                  ( "pair"
> -                  , [| Dt.StrPointerF ("two", [||])
> -                     ; Dt.StrPointerF ("three", [||]) |] ) |] )) ]
> +           ( "pair",
> +             [| Dt.StrPointerF ("one", [||]);
> +                Dt.StrPointerF
> +                  ( "pair",
> +                    [| Dt.StrPointerF ("two", [||]);
> +                       Dt.StrPointerF ("three", [||])
> +                    |] )
> +             |] ))
> +    ]
>  
>  let sort21312 () =
>    testMachineNoTc
> @@ -468,22 +499,27 @@ let sort21312 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "pair"
> -           , [| Dt.StrPointerF ("one", [||])
> -              ; Dt.StrPointerF
> -                  ( "pair"
> -                  , [| Dt.StrPointerF ("one", [||])
> -                     ; Dt.StrPointerF
> -                         ( "pair"
> -                         , [| Dt.StrPointerF ("two", [||])
> -                            ; Dt.StrPointerF
> -                                ( "pair"
> -                                , [| Dt.StrPointerF ("two", [||])
> -                                   ; Dt.StrPointerF
> -                                       ( "pair"
> -                                       , [| Dt.StrPointerF ("three", [||])
> -                                          ; Dt.StrPointerF ("null", [||]) |] )
> -                                  |] ) |] ) |] ) |] )) ]
> +           ( "pair",
> +             [| Dt.StrPointerF ("one", [||]);
> +                Dt.StrPointerF
> +                  ( "pair",
> +                    [| Dt.StrPointerF ("one", [||]);
> +                       Dt.StrPointerF
> +                         ( "pair",
> +                           [| Dt.StrPointerF ("two", [||]);
> +                              Dt.StrPointerF
> +                                ( "pair",
> +                                  [| Dt.StrPointerF ("two", [||]);
> +                                     Dt.StrPointerF
> +                                       ( "pair",
> +                                         [| Dt.StrPointerF ("three", [||]);
> +                                            Dt.StrPointerF ("null", [||])
> +                                         |] )
> +                                  |] )
> +                           |] )
> +                    |] )
> +             |] ))
> +    ]
>  
>  let backtrackDfs () =
>    testMachineNoTc
> @@ -497,12 +533,15 @@ let backtrackDfs () =
>      \    "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "cons"
> -           , [| Dt.StrPointerF ("right", [||])
> -              ; Dt.StrPointerF
> -                  ( "cons"
> -                  , [| Dt.StrPointerF ("left", [||])
> -                     ; Dt.StrPointerF ("eol", [||]) |] ) |] )) ]
> +           ( "cons",
> +             [| Dt.StrPointerF ("right", [||]);
> +                Dt.StrPointerF
> +                  ( "cons",
> +                    [| Dt.StrPointerF ("left", [||]);
> +                       Dt.StrPointerF ("eol", [||])
> +                    |] )
> +             |] ))
> +    ]
>  
>  let backtrackDfs2 () =
>    testMachineNoTc
> @@ -516,31 +555,34 @@ let backtrackDfs2 () =
>      \    "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "cons"
> -           , [| Dt.StrPointerF ("left", [||])
> -              ; Dt.StrPointerF
> -                  ( "cons"
> -                  , [| Dt.StrPointerF ("right", [||])
> -                     ; Dt.StrPointerF ("eol", [||]) |] ) |] )) ]
> +           ( "cons",
> +             [| Dt.StrPointerF ("left", [||]);
> +                Dt.StrPointerF
> +                  ( "cons",
> +                    [| Dt.StrPointerF ("right", [||]);
> +                       Dt.StrPointerF ("eol", [||])
> +                    |] )
> +             |] ))
> +    ]
>  
>  let testIs () =
>    testMachineNoTc "f(X) :- X is 3.\n  ?- f(Y)\n  "
> -    [Dt.HeapPointerF (Dt.IntF 3)]
> +    [ Dt.HeapPointerF (Dt.IntF 3) ]
>  
>  let add2 () =
>    testMachineNoTc "f(X) :- X is 3 + 4.\n  ?- f(Y)\n  "
> -    [Dt.HeapPointerF (Dt.IntF 7)]
> +    [ Dt.HeapPointerF (Dt.IntF 7) ]
>  
>  let add3 () =
>    testMachineNoTc "f(X,Y) :- X is 3 + Y.\n  ?- f(X,3)\n  "
> -    [Dt.HeapPointerF (Dt.IntF 6)]
> +    [ Dt.HeapPointerF (Dt.IntF 6) ]
>  
>  let neg1 () =
>    testMachineNoTc "\n  f(X) :- X is 3 - 1.\n\n  ?- f(Y)\n  "
> -    [Dt.HeapPointerF (Dt.IntF 2)]
> +    [ Dt.HeapPointerF (Dt.IntF 2) ]
>  
>  let fibNum () =
> -  logError (fun m -> m "hereE") ;
> +  logError (fun m -> m "hereE");
>    testMachineNoTc
>      "\n\
>      \  fib(0,0).\n\
> @@ -549,30 +591,30 @@ let fibNum () =
>      \  fib(Arg2,Ans2), Y is Ans1 + Ans2.\n\n\
>      \  ?- fib(9,X)\n\
>      \  "
> -    [Dt.HeapPointerF (Dt.IntF 34)]
> +    [ Dt.HeapPointerF (Dt.IntF 34) ]
>  
>  let loadArgOrder () =
>    testMachineNoTc
>      "\n  i(g(h(Z),Z)).\n  f(X) :- i(X).\n  ?-f(g(h(3),X))\n  "
> -    [Dt.HeapPointerF (Dt.IntF 3)]
> +    [ Dt.HeapPointerF (Dt.IntF 3) ]
>  
>  let testBigStruct () =
>    testMachineNoTc
>      "\n  i(g(h(Z),3)).\n  f(X) :- i(g(h(X),X)).\n  ?-f(X)\n  "
> -    [Dt.HeapPointerF (Dt.IntF 3)]
> +    [ Dt.HeapPointerF (Dt.IntF 3) ]
>  
>  let anotherTest () =
>    testMachineNoTc
>      "\n  i(g(h(Z),Z)).\n  f(X) :- i(X).\n  ?-f(g(h(3),X))\n  "
> -    [Dt.HeapPointerF (Dt.IntF 3)]
> +    [ Dt.HeapPointerF (Dt.IntF 3) ]
>  
>  let putTest1 () =
>    testMachineNoTc "\n  i(g(X,h(3))).\n  ?-i(g(X,h(X)))\n  "
> -    [Dt.HeapPointerF (Dt.IntF 3)]
> +    [ Dt.HeapPointerF (Dt.IntF 3) ]
>  
>  let putTest2 () =
>    testMachineNoTc "\n  i(g(3,h(X))).\n  ?-i(g(X,h(X)))\n  "
> -    [Dt.HeapPointerF (Dt.IntF 3)]
> +    [ Dt.HeapPointerF (Dt.IntF 3) ]
>  
>  let build1 () =
>    testMachineNoTc
> @@ -583,11 +625,13 @@ let build1 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "cons"
> -           , [| Dt.StrPointerF
> -                  ( "cons"
> -                  , [| Dt.StrPointerF
> -                         ("cons", [|Dt.StrPointerF ("null", [||])|]) |] ) |] ))
> +           ( "cons",
> +             [| Dt.StrPointerF
> +                  ( "cons",
> +                    [| Dt.StrPointerF
> +                         ("cons", [| Dt.StrPointerF ("null", [||]) |])
> +                    |] )
> +             |] ))
>      ]
>  
>  let aliasing () =
> @@ -599,19 +643,22 @@ let aliasing () =
>      \  s(A).\n\n\
>      \  ?- p(X,Y)\n\n\
>      \  "
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("a", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("a", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("a", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("a", [||]))
> +    ]
>  
>  let uniffff () =
>    testMachineNoTc
>      "\n  dog(dusk).\n  unif(X,X).\n\n  ?-  unif(X,f(Y)), dog(Y)\n  "
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("f", [|Dt.StrPointerF ("dusk", [||])|]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
> +    [ Dt.HeapPointerF
> +        (Dt.StrPointerF ("f", [| Dt.StrPointerF ("dusk", [||]) |]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> +    ]
>  
>  let alia3 () =
>    testMachineNoTc
>      "\n  p(X) :- q(X,X).\n  q(a,Y) :- r(Y).\n  r(a).\n\n  ?- p(X)\n  "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("a", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("a", [||])) ]
>  
>  let mincut () =
>    testMachineNoTc
> @@ -621,7 +668,7 @@ let mincut () =
>      \  notone(Y) :- equals(1, Y), !, fail.\n\
>      \  notone(Y).\n\n\n\
>      \  ?-  num(X), notone(X)"
> -    [Dt.HeapPointerF (Dt.IntF 2)]
> +    [ Dt.HeapPointerF (Dt.IntF 2) ]
>  
>  let headdif1 () =
>    testMachineNoTc
> @@ -641,10 +688,12 @@ let headdif1 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "c"
> -           , [| Dt.IntF 2
> -              ; Dt.StrPointerF
> -                  ("c", [|Dt.IntF 1; Dt.StrPointerF ("eol", [||])|]) |] )) ]
> +           ( "c",
> +             [| Dt.IntF 2;
> +                Dt.StrPointerF
> +                  ("c", [| Dt.IntF 1; Dt.StrPointerF ("eol", [||]) |])
> +             |] ))
> +    ]
>  
>  let queens8 () =
>    testMachineNoTc
> @@ -679,33 +728,40 @@ let queens8 () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "c"
> -           , [| Dt.IntF 1
> -              ; Dt.StrPointerF
> -                  ( "c"
> -                  , [| Dt.IntF 5
> -                     ; Dt.StrPointerF
> -                         ( "c"
> -                         , [| Dt.IntF 8
> -                            ; Dt.StrPointerF
> -                                ( "c"
> -                                , [| Dt.IntF 6
> -                                   ; Dt.StrPointerF
> -                                       ( "c"
> -                                       , [| Dt.IntF 3
> -                                          ; Dt.StrPointerF
> -                                              ( "c"
> -                                              , [| Dt.IntF 7
> -                                                 ; Dt.StrPointerF
> -                                                     ( "c"
> -                                                     , [| Dt.IntF 2
> -                                                        ; Dt.StrPointerF
> -                                                            ( "c"
> -                                                            , [| Dt.IntF 4
> -                                                               ; Dt.StrPointerF
> +           ( "c",
> +             [| Dt.IntF 1;
> +                Dt.StrPointerF
> +                  ( "c",
> +                    [| Dt.IntF 5;
> +                       Dt.StrPointerF
> +                         ( "c",
> +                           [| Dt.IntF 8;
> +                              Dt.StrPointerF
> +                                ( "c",
> +                                  [| Dt.IntF 6;
> +                                     Dt.StrPointerF
> +                                       ( "c",
> +                                         [| Dt.IntF 3;
> +                                            Dt.StrPointerF
> +                                              ( "c",
> +                                                [| Dt.IntF 7;
> +                                                   Dt.StrPointerF
> +                                                     ( "c",
> +                                                       [| Dt.IntF 2;
> +                                                          Dt.StrPointerF
> +                                                            ( "c",
> +                                                              [| Dt.IntF 4;
> +                                                                 Dt.StrPointerF
>                                                                     ("eol", [||])
> -                                                              |] ) |] ) |] )
> -                                         |] ) |] ) |] ) |] ) |] )) ]
> +                                                              |] )
> +                                                       |] )
> +                                                |] )
> +                                         |] )
> +                                  |] )
> +                           |] )
> +                    |] )
> +             |] ))
> +    ]
>  
>  let bigunif () =
>    testMachineNoTc
> @@ -713,40 +769,44 @@ let bigunif () =
>      \      dog(dusk).\n\
>      \      unif(X,X).\n\n\
>      \      ?-  unif(A,B), unif(C,D), unif(B,C), dog(A)"
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> +    ]
>  
>  let unif1 () =
>    testMachineNoTc
>      "unif(X,X).\n\
>      \  dog(dusk).\n\n\
>      \  ?- unif(A,B), unif(C,D), unif(A,D), dog(A)"
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> +    ]
>  
>  let unif2 () =
>    testMachineNoTc
>      "unif(X,X).\n\
>      \       dog(dusk).\n\n\
>      \       ?- unif(A,B), unif(C,D), unif(A,C), dog(A)"
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> +    ]
>  
>  let unif3 () =
>    testMachineNoTc
>      "unif(X,X).\n\
>      \            dog(dusk).\n\n\
>      \            ?- unif(A,B), unif(C,D), unif(A,C), dog(C)"
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||])) ]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> +    ]
>  
>  let unifStructs () =
>    testMachineNoTc
> @@ -755,10 +815,11 @@ let unifStructs () =
>      \  dog(dusk).\n\n\
>      \  ?- unif(f(A),f(B)), unif(f(C),D), unif(f(A),f(C)), dog(A)\n\
>      \  "
> -    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]))
> -    ; Dt.HeapPointerF (Dt.StrPointerF ("f", [|Dt.StrPointerF ("dusk", [||])|]))
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF (Dt.StrPointerF ("dusk", [||]));
> +      Dt.HeapPointerF
> +        (Dt.StrPointerF ("f", [| Dt.StrPointerF ("dusk", [||]) |]))
>      ]
>  
>  let miniperm () =
> @@ -773,10 +834,12 @@ let miniperm () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "c"
> -           , [| Dt.IntF 2
> -              ; Dt.StrPointerF
> -                  ("c", [|Dt.IntF 1; Dt.StrPointerF ("eol", [||])|]) |] )) ]
> +           ( "c",
> +             [| Dt.IntF 2;
> +                Dt.StrPointerF
> +                  ("c", [| Dt.IntF 1; Dt.StrPointerF ("eol", [||]) |])
> +             |] ))
> +    ]
>  
>  let minitree () =
>    testMachineNoTc
> @@ -789,14 +852,15 @@ let minitree () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "cons"
> -           , [|Dt.StrPointerF ("right", [||]); Dt.StrPointerF ("eol", [||])|]
> -           )) ]
> +           ( "cons",
> +             [| Dt.StrPointerF ("right", [||]); Dt.StrPointerF ("eol", [||]) |]
> +           ))
> +    ]
>  
>  let listy () =
>    testMachineNoTc
>      "\n\n  dfs(V,tree(V),eol).\n\n  ?- dfs(two,tree(two),X)\n  "
> -    [Dt.HeapPointerF (Dt.StrPointerF ("eol", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("eol", [||])) ]
>  
>  let rightright () =
>    testMachineNoTc
> @@ -808,12 +872,15 @@ let rightright () =
>      \  "
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "cons"
> -           , [| Dt.StrPointerF ("right", [||])
> -              ; Dt.StrPointerF
> -                  ( "cons"
> -                  , [| Dt.StrPointerF ("right", [||])
> -                     ; Dt.StrPointerF ("eol", [||]) |] ) |] )) ]
> +           ( "cons",
> +             [| Dt.StrPointerF ("right", [||]);
> +                Dt.StrPointerF
> +                  ( "cons",
> +                    [| Dt.StrPointerF ("right", [||]);
> +                       Dt.StrPointerF ("eol", [||])
> +                    |] )
> +             |] ))
> +    ]
>  
>  let testgetint () =
>    testMachineNoTc
> @@ -822,7 +889,7 @@ let testgetint () =
>      \    r(1).\n\
>      \    s(X).\n\n\
>      \    ?- p(X,Y)"
> -    [Dt.HeapPointerF (Dt.IntF 1); Dt.HeapPointerF (Dt.IntF 1)]
> +    [ Dt.HeapPointerF (Dt.IntF 1); Dt.HeapPointerF (Dt.IntF 1) ]
>  
>  let clearT () =
>    testMachineNoTc
> @@ -844,7 +911,7 @@ let cutInStack () =
>       res(a) :- g.\n\
>       res(b) :- f.\n\n\
>       ?- res(X)"
> -    [Dt.HeapPointerF (Dt.StrPointerF ("b", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("b", [||])) ]
>  
>  let crapsort1 () =
>    testMachineNoTc
> @@ -864,7 +931,7 @@ let crapsort1 () =
>      \    sorted(c(H1,c(H2,T))) :- leq(H1,H2), sorted(c(H2,T)).\n\n\
>      \    terribleSort(X,Y) :- perm(c(2,c(3,c(1,c(2,eol)))),A), sorted(Y).\n\n\n\
>      \    ?- terribleSort(c(2,c(3,c(1,c(2,eol)))),A)"
> -    [Dt.HeapPointerF (Dt.StrPointerF ("eol", [||]))]
> +    [ Dt.HeapPointerF (Dt.StrPointerF ("eol", [||])) ]
>  
>  let crapsort2 () =
>    testMachineNoTc
> @@ -885,79 +952,84 @@ let crapsort2 () =
>      \    ?- terribleSort(c(2,c(3,c(1,c(2,eol)))),A)"
>      [ Dt.HeapPointerF
>          (Dt.StrPointerF
> -           ( "c"
> -           , [| Dt.IntF 1
> -              ; Dt.StrPointerF
> -                  ( "c"
> -                  , [| Dt.IntF 2
> -                     ; Dt.StrPointerF
> -                         ( "c"
> -                         , [| Dt.IntF 2
> -                            ; Dt.StrPointerF
> -                                ( "c"
> -                                , [|Dt.IntF 3; Dt.StrPointerF ("eol", [||])|]
> -                                ) |] ) |] ) |] )) ]
> +           ( "c",
> +             [| Dt.IntF 1;
> +                Dt.StrPointerF
> +                  ( "c",
> +                    [| Dt.IntF 2;
> +                       Dt.StrPointerF
> +                         ( "c",
> +                           [| Dt.IntF 2;
> +                              Dt.StrPointerF
> +                                ( "c",
> +                                  [| Dt.IntF 3; Dt.StrPointerF ("eol", [||]) |]
> +                                )
> +                           |] )
> +                    |] )
> +             |] ))
> +    ]
>  
>  let tests_notc =
> -  [ "test1" >:: test1
> -  ; "test2" >:: test2
> -  ; "test3" >:: test3
> -  ; "test4" >:: test4
> -  ; "test6" >:: test6
> -  ; "backtrack" >:: backtrack
> -  ; "doubleVar" >:: doubleVar
> -  ; "swaps1" >:: swaps1
> -  ; "noSwaps" >:: noSwaps
> -  ; "swaps2" >:: swaps2
> -  ; "buildStruct1" >:: buildStruct1
> -  ; "buildStruct2" >:: buildStruct2
> -  ; "nestedStructures" >:: nestedStructures
> -  ; "plus1" >:: plus1
> -  ; "plus2" >:: plus2
> -  ; "inStruct" >:: inStruct
> -  ; "alpha" >:: alpha
> -  ; "zeroPLus2" >:: zeroPLus2
> -  ; "fib2" >:: fib2
> -  ; "twop3" >:: twop3
> -  ; "addOneFun" >:: addOneFun
> -  ; "fib4" >:: fib4
> -  ; "fib13" >:: fib13
> -  ; "pairOne" >:: pairOne
> -  ; "cyclicTest" >:: cyclicTest
> -  ; "tripleBacktrack" >:: tripleBacktrack
> -  ; "geqTest" >:: geqTest
> -  ; "quick21" >:: quick21
> -  ; "quick213" >:: quick213
> -  ; "sort21312" >:: sort21312
> -  ; "backtrackDfs" >:: backtrackDfs
> -  ; "backtrackDfs2" >:: backtrackDfs2
> -  ; "testIs" >:: testIs
> -  ; "add2" >:: add2
> -  ; "add3" >:: add3
> -  ; "neg1" >:: neg1
> -  ; "loadArgOrder" >:: loadArgOrder
> -  ; "testBigStruct" >:: testBigStruct
> -  ; "anotherTest" >:: anotherTest
> -  ; "putTest1" >:: putTest1
> -  ; "putTest2" >:: putTest2
> -  ; "build1" >:: build1
> -  ; "aliasing" >:: aliasing
> -  ; "uniffff" >:: uniffff
> -  ; "alia3" >:: alia3
> -  ; "mincut" >:: mincut
> -  ; "headdif1" >:: headdif1
> -  ; "queens8" >:: queens8
> -  ; "bigunif" >:: bigunif
> -  ; "unif1" >:: unif1
> -  ; "unif2" >:: unif2
> -  ; "unif3" >:: unif3
> -  ; "unifStructs" >:: unifStructs
> -  ; "miniperm" >:: miniperm
> -  ; "listy" >:: listy
> -  ; "rightright" >:: rightright
> -  ; "testgetint" >:: testgetint
> -  ; "fibNum" >:: fibNum
> -  ; "clearT" >:: clearT
> -  ; "cutInStack" >:: cutInStack
> -  ; "crapsort1" >:: crapsort1
> -  ; "crapsort2" >:: crapsort2 ]
> +  [ "test1" >:: test1;
> +    "test2" >:: test2;
> +    "test3" >:: test3;
> +    "test4" >:: test4;
> +    "test6" >:: test6;
> +    "backtrack" >:: backtrack;
> +    "doubleVar" >:: doubleVar;
> +    "swaps1" >:: swaps1;
> +    "noSwaps" >:: noSwaps;
> +    "swaps2" >:: swaps2;
> +    "buildStruct1" >:: buildStruct1;
> +    "buildStruct2" >:: buildStruct2;
> +    "nestedStructures" >:: nestedStructures;
> +    "plus1" >:: plus1;
> +    "plus2" >:: plus2;
> +    "inStruct" >:: inStruct;
> +    "alpha" >:: alpha;
> +    "zeroPLus2" >:: zeroPLus2;
> +    "fib2" >:: fib2;
> +    "twop3" >:: twop3;
> +    "addOneFun" >:: addOneFun;
> +    "fib4" >:: fib4;
> +    "fib13" >:: fib13;
> +    "pairOne" >:: pairOne;
> +    "cyclicTest" >:: cyclicTest;
> +    "tripleBacktrack" >:: tripleBacktrack;
> +    "geqTest" >:: geqTest;
> +    "quick21" >:: quick21;
> +    "quick213" >:: quick213;
> +    "sort21312" >:: sort21312;
> +    "backtrackDfs" >:: backtrackDfs;
> +    "backtrackDfs2" >:: backtrackDfs2;
> +    "testIs" >:: testIs;
> +    "add2" >:: add2;
> +    "add3" >:: add3;
> +    "neg1" >:: neg1;
> +    "loadArgOrder" >:: loadArgOrder;
> +    "testBigStruct" >:: testBigStruct;
> +    "anotherTest" >:: anotherTest;
> +    "putTest1" >:: putTest1;
> +    "putTest2" >:: putTest2;
> +    "build1" >:: build1;
> +    "aliasing" >:: aliasing;
> +    "uniffff" >:: uniffff;
> +    "alia3" >:: alia3;
> +    "mincut" >:: mincut;
> +    "headdif1" >:: headdif1;
> +    "queens8" >:: queens8;
> +    "bigunif" >:: bigunif;
> +    "unif1" >:: unif1;
> +    "unif2" >:: unif2;
> +    "unif3" >:: unif3;
> +    "unifStructs" >:: unifStructs;
> +    "miniperm" >:: miniperm;
> +    "listy" >:: listy;
> +    "rightright" >:: rightright;
> +    "testgetint" >:: testgetint;
> +    "fibNum" >:: fibNum;
> +    "clearT" >:: clearT;
> +    "cutInStack" >:: cutInStack;
> +    "crapsort1" >:: crapsort1;
> +    "crapsort2" >:: crapsort2
> +  ]
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/typecheck/unifyTypes.ml) > _build/default/src/typecheck/.formatted/unifyTypes.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/typecheck/checkTypeEquivalence.ml) > _build/default/src/typecheck/.formatted/checkTypeEquivalence.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/typecheck/checkTypeEquivalence.ml src/typecheck/.formatted/checkTypeEquivalence.ml)
> diff --git a/src/typecheck/checkTypeEquivalence.ml b/src/typecheck/.formatted/checkTypeEquivalence.ml
> index 89aeabe..787de59 100644
> --- a/src/typecheck/checkTypeEquivalence.ml
> +++ b/src/typecheck/.formatted/checkTypeEquivalence.ml
> @@ -17,8 +17,9 @@ let rec checkTypeEquiv x y =
>      logDebug (fun m -> m "check type equiv h %a and %a" pp_in1 x pp_in2 y)
>    in
>    match (x, y) with
> -  | _, TypeVar _ -> (*  TODO need to add to inferred map?? think  *)
> -                    ()
> +  | _, TypeVar _ ->
> +      (*  TODO need to add to inferred map?? think  *)
> +      ()
>    | TypeVar ("Any", -1), _ -> ()
>    | TypeVar (_name, _num), _notTypeVar ->
>        raise (Err "TypeVar not equivalent to notTypeVar")
> @@ -32,7 +33,7 @@ let rec checkTypeEquiv x y =
>                \          \n\
>                \ %a : %a  \n\n\n\n\
>                \ %a : %a\n"
> -              pp_var name pp_t1 args pp_var name2 pp_t2 args2 )
> +              pp_var name pp_t1 args pp_var name2 pp_t2 args2)
>        in
>        if name = name2 && List.length args = List.length args2 then
>          List.iter2_exn ~f:checkTypeEquiv args args2
> @@ -51,11 +52,11 @@ let rec checkTypesAreEquivalent (list1 : (var * intnum) typeins sexp_list)
>      (list2 : var typeins sexp_list) =
>    let () =
>      logDebug (fun m ->
> -        m "check types are equivalent list %a %a \n\n" pp_a list1 pp_b list2 )
> +        m "check types are equivalent list %a %a \n\n" pp_a list1 pp_b list2)
>    in
>    match (list1, list2) with
>    | x :: xs, y :: ys ->
> -      checkTypeEquiv x y ;
> +      checkTypeEquiv x y;
>        checkTypesAreEquivalent xs ys
>    | [], [] -> ()
>    | _ ->
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/typecheck/unifyTypes.ml src/typecheck/.formatted/unifyTypes.ml)
> diff --git a/src/typecheck/unifyTypes.ml b/src/typecheck/.formatted/unifyTypes.ml
> index 28953d4..e343efd 100644
> --- a/src/typecheck/unifyTypes.ml
> +++ b/src/typecheck/.formatted/unifyTypes.ml
> @@ -6,23 +6,23 @@ open Logging
>  let rec unifyTypesOfInferredVars result a b =
>    let () =
>      logDebug (fun m ->
> -        m "unifyTypesOfInferredVars %a and %a\n\n" pp_infv a pp_infv b )
> +        m "unifyTypesOfInferredVars %a and %a\n\n" pp_infv a pp_infv b)
>    in
>    match (a, b) with
>    | TypeVar (x, 0), TypeVar (y, 0) ->
>        if x = y then ()
>        else raise (Err ("Different user-defined types do not unify " ^ x ^ y))
>    | TypeVar (x, 0), TypeVar (y, n) -> (
> -      logDebug (fun m -> m "hiiii") ;
> +      logDebug (fun m -> m "hiiii");
>        match Hashtbl.find result (y, n) with
>        | None ->
>            if (y, n) = (x, 0) then ()
>            else Hashtbl.add_exn result ~key:(y, n) ~data:(TypeVar (x, 0))
>        | Some res -> unifyTypesOfInferredVars result a res )
>    | TypeVar (y, n), TypeVar (x, 0) -> (
> -    match Hashtbl.find result (y, n) with
> -    | None -> Hashtbl.add_exn result ~key:(y, n) ~data:(TypeVar (x, 0))
> -    | Some res -> unifyTypesOfInferredVars result res b )
> +      match Hashtbl.find result (y, n) with
> +      | None -> Hashtbl.add_exn result ~key:(y, n) ~data:(TypeVar (x, 0))
> +      | Some res -> unifyTypesOfInferredVars result res b )
>    | TypeVar (y, n), TypeVar (x, n2) -> (
>        if (y, n) = (x, n2) then ()
>        else if n < n2 then
> @@ -34,13 +34,13 @@ let rec unifyTypesOfInferredVars result a b =
>          | None -> Hashtbl.add_exn result ~key:(x, n2) ~data:(TypeVar (y, n))
>          | Some res -> unifyTypesOfInferredVars result a res )
>    | TypeVar x, other -> (
> -    match Hashtbl.find result x with
> -    | None -> Hashtbl.add_exn result ~key:x ~data:other
> -    | Some res -> unifyTypesOfInferredVars result res other )
> +      match Hashtbl.find result x with
> +      | None -> Hashtbl.add_exn result ~key:x ~data:other
> +      | Some res -> unifyTypesOfInferredVars result res other )
>    | other, TypeVar x -> (
> -    match Hashtbl.find result x with
> -    | None -> Hashtbl.add_exn result ~key:x ~data:other
> -    | Some res -> unifyTypesOfInferredVars result other res )
> +      match Hashtbl.find result x with
> +      | None -> Hashtbl.add_exn result ~key:x ~data:other
> +      | Some res -> unifyTypesOfInferredVars result other res )
>    | TypeCons (n1, ag1), TypeCons (n2, ag2) ->
>        if n1 = n2 then
>          List.iter2_exn ~f:(unifyTypesOfInferredVars result) ag1 ag2
> @@ -54,13 +54,13 @@ let rec unifyTypesDecVarToRenamed predVariableBindings bodyVariableBindings a b
>    let () =
>      logDebug (fun m ->
>          m "unifyTypesDecVarToRenamed %a  and %a\n\n" (pp_typeins pp_var) a
> -          pp_infv b )
> +          pp_infv b)
>    in
>    match (a, b) with
>    | TypeVar x, y -> (
> -    match Hashtbl.find predVariableBindings x with
> -    | None -> Hashtbl.add_exn predVariableBindings ~key:x ~data:y
> -    | Some res -> unifyTypesOfInferredVars bodyVariableBindings res y )
> +      match Hashtbl.find predVariableBindings x with
> +      | None -> Hashtbl.add_exn predVariableBindings ~key:x ~data:y
> +      | Some res -> unifyTypesOfInferredVars bodyVariableBindings res y )
>    | TypeCons (n1, ag1), TypeCons (n2, ag2) ->
>        if n1 = n2 then
>          List.iter2_exn
> @@ -93,9 +93,9 @@ let unifyTypesDecVarToRenamedList xs ys =
>  let rec appVarSubst varBindings x =
>    match x with
>    | TypeVar y -> (
> -    match Hashtbl.find varBindings y with
> -    | Some y -> appVarSubst varBindings y
> -    | None -> x )
> +      match Hashtbl.find varBindings y with
> +      | Some y -> appVarSubst varBindings y
> +      | None -> x )
>    | TypeCons (name, args) ->
>        TypeCons (name, List.map ~f:(appVarSubst varBindings) args)
>    | IntTyp -> IntTyp
> @@ -105,9 +105,9 @@ let rec appDefSubst
>      =
>    match Hashtbl.find predBindings x with
>    | Some y -> (
> -    match y with
> -    | TypeVar x -> appVarSubst varBindings (TypeVar x)
> -    | other -> other )
> +      match y with
> +      | TypeVar x -> appVarSubst varBindings (TypeVar x)
> +      | other -> other )
>    | None -> TypeVar ("Any", -1)
>  
>  let applySubst ls predBindings varBindings =
> @@ -136,13 +136,15 @@ let rec checkSubTypeBound varTypeMapping x y =
>    | TypeVar (n1, 0), TypeVar (n2, 0) ->
>        if n1 = n2 then () else raise (Err "No sub type user defined var")
>    | TypeVar (x, 0), TypeVar (y, n) -> (
> -    match Hashtbl.find varTypeMapping (y, n) with
> -    | None -> Hashtbl.add_exn varTypeMapping ~key:(y, n) ~data:(TypeVar (x, 0))
> -    | Some res -> checkSubTypeBound varTypeMapping (TypeVar (x, 0)) res )
> +      match Hashtbl.find varTypeMapping (y, n) with
> +      | None ->
> +          Hashtbl.add_exn varTypeMapping ~key:(y, n) ~data:(TypeVar (x, 0))
> +      | Some res -> checkSubTypeBound varTypeMapping (TypeVar (x, 0)) res )
>    | TypeVar (y, n), TypeVar (x, 0) -> (
> -    match Hashtbl.find varTypeMapping (y, n) with
> -    | None -> Hashtbl.add_exn varTypeMapping ~key:(y, n) ~data:(TypeVar (x, 0))
> -    | Some res -> checkSubTypeBound varTypeMapping res (TypeVar (x, 0)) )
> +      match Hashtbl.find varTypeMapping (y, n) with
> +      | None ->
> +          Hashtbl.add_exn varTypeMapping ~key:(y, n) ~data:(TypeVar (x, 0))
> +      | Some res -> checkSubTypeBound varTypeMapping res (TypeVar (x, 0)) )
>    | TypeVar (y, n), TypeVar (x, n2) -> (
>        if (y, n) = (x, n2) then ()
>        else if n < n2 then
> @@ -161,31 +163,32 @@ let rec checkSubType predTypeMapping varTypeMapping x y =
>    let () =
>      logDebug (fun m ->
>          m "check is sub type %a %a \n\n" (pp_typeins pp_var) x
> -          (pp_typeins pp_strint) y )
> +          (pp_typeins pp_strint) y)
>    in
>    match (x, y) with
>    | TypeVar x, TypeVar (n, 0) -> (
> -    match Hashtbl.find predTypeMapping x with
> -    | None -> Hashtbl.add_exn predTypeMapping ~key:x ~data:(TypeVar (n, 0))
> -    | Some e ->
> -        if e = TypeVar (n, 0) then ()
> -        else logDebug (fun m -> m "found %a" pp_infv e) ;
> -        unifyTypesOfInferredVars varTypeMapping e (TypeVar (n, 0))
> -        (* raise (Err "Will not unify type constrained by annotation") *) )
> +      match Hashtbl.find predTypeMapping x with
> +      | None -> Hashtbl.add_exn predTypeMapping ~key:x ~data:(TypeVar (n, 0))
> +      | Some e ->
> +          if e = TypeVar (n, 0) then ()
> +          else logDebug (fun m -> m "found %a" pp_infv e);
> +          unifyTypesOfInferredVars varTypeMapping e (TypeVar (n, 0))
> +      (* raise (Err "Will not unify type constrained by annotation") *) )
>    | TypeVar x, TypeVar (name, num) -> (
> -    match Hashtbl.find predTypeMapping x with
> -    | None ->
> -        Hashtbl.add_exn predTypeMapping ~key:x ~data:(TypeVar (name, num))
> -    | Some e -> unifyTypesOfInferredVars varTypeMapping e (TypeVar (name, num))
> -    )
> +      match Hashtbl.find predTypeMapping x with
> +      | None ->
> +          Hashtbl.add_exn predTypeMapping ~key:x ~data:(TypeVar (name, num))
> +      | Some e ->
> +          unifyTypesOfInferredVars varTypeMapping e (TypeVar (name, num)) )
>    | TypeVar x, other -> (
> -    match Hashtbl.find predTypeMapping x with
> -    | None -> Hashtbl.add_exn predTypeMapping ~key:x ~data:other
> -    | Some e -> unifyTypesOfInferredVars varTypeMapping e other )
> +      match Hashtbl.find predTypeMapping x with
> +      | None -> Hashtbl.add_exn predTypeMapping ~key:x ~data:other
> +      | Some e -> unifyTypesOfInferredVars varTypeMapping e other )
>    | _, TypeVar (_, 0) ->
>        raise (Err "Will not unify type constrained by annotation")
> -  | _, TypeVar ("Any", -1) -> (* TODO try to break this case  *)
> -                              ()
> +  | _, TypeVar ("Any", -1) ->
> +      (* TODO try to break this case  *)
> +      ()
>    (* TODO TYPEVAR N CASE *)
>    | IntTyp, IntTyp -> ()
>    | IntTyp, _ -> raise (Err "")
> @@ -206,12 +209,11 @@ let rec checkIsSubType predTypeMapping varTypeMapping
>      (list2 : (string * intnum) typeins sexp_list) =
>    let () =
>      logDebug (fun m ->
> -        m "check is sub type list %a %a \n\n" pp_typlis list1 pp_typlisn list2
> -    )
> +        m "check is sub type list %a %a \n\n" pp_typlis list1 pp_typlisn list2)
>    in
>    match (list1, list2) with
>    | x :: xs, y :: ys ->
> -      checkSubType predTypeMapping varTypeMapping x y ;
> +      checkSubType predTypeMapping varTypeMapping x y;
>        checkIsSubType predTypeMapping varTypeMapping xs ys
>    | [], [] -> ()
>    | _ -> raise (Err "Type lists have different lengths so aren't equivalent")
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/typecheck/getDeclarations.ml) > _build/default/src/typecheck/.formatted/getDeclarations.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/typecheck/getDeclarations.ml src/typecheck/.formatted/getDeclarations.ml)
> diff --git a/src/typecheck/getDeclarations.ml b/src/typecheck/.formatted/getDeclarations.ml
> index 050a608..818b116 100644
> --- a/src/typecheck/getDeclarations.ml
> +++ b/src/typecheck/.formatted/getDeclarations.ml
> @@ -11,7 +11,7 @@ let getPredTypes body =
>          match x with
>          | P (PredDef (name, types)) ->
>              Hashtbl.add_exn result ~key:name ~data:types
> -        | _ -> () )
> +        | _ -> ())
>        body
>    in
>    result
> @@ -26,14 +26,14 @@ let getTypeDefs body =
>          match x with
>          | D (TypeDef (name, vars, cases)) ->
>              Hashtbl.add_exn result ~key:name ~data:(vars, cases)
> -        | _ -> () )
> +        | _ -> ())
>        body
>    in
>    let () = logDebug (fun m -> m "The type defs are") in
>    let () =
>      Hashtbl.iteri
>        ~f:(fun ~key:k ~data:v ->
> -        logDebug (fun m -> m "%a, %a" pp_funct k (pp_typdefright pp_var) v) )
> +        logDebug (fun m -> m "%a, %a" pp_funct k (pp_typdefright pp_var) v))
>        result
>    in
>    let () = logDebug (fun m -> m "") in
> @@ -50,15 +50,15 @@ let reverse
>            ~f:(fun (TypeDefRight (name, args)) ->
>              Hashtbl.add_exn result
>                ~key:(name, List.length args)
> -              ~data:(k, vars, args) )
> -          cases )
> +              ~data:(k, vars, args))
> +          cases)
>        typeDefs
>    in
>    let () = logDebug (fun m -> m "constructor to type is") in
>    let () =
>      Hashtbl.iteri
>        ~f:(fun ~key:(v, i) ~data:_ ->
> -        logDebug (fun m -> m "%a %a body?" pp_var v pp_intnum i) )
> +        logDebug (fun m -> m "%a %a body?" pp_var v pp_intnum i))
>        result
>    in
>    let () = logDebug (fun m -> m "") in
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/typecheck/checkClause.ml) > _build/default/src/typecheck/.formatted/checkClause.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/typecheck/inferVariableTypes.ml) > _build/default/src/typecheck/.formatted/inferVariableTypes.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/typecheck/checkClause.ml src/typecheck/.formatted/checkClause.ml)
> diff --git a/src/typecheck/checkClause.ml b/src/typecheck/.formatted/checkClause.ml
> index d586cf8..caa69f7 100644
> --- a/src/typecheck/checkClause.ml
> +++ b/src/typecheck/.formatted/checkClause.ml
> @@ -13,7 +13,7 @@ let rec getTypeOfArgumentTerm variableTypes
>        match varType with
>        | Some e -> e
>        | None ->
> -          logError (fun m -> m "lokoup failed for %a" pp_var x) ;
> +          logError (fun m -> m "lokoup failed for %a" pp_var x);
>            raise Oops )
>    | TInt _ -> IntTyp
>    | TFun (name, funargs) ->
> @@ -37,7 +37,7 @@ let rec getTypeOfArgumentTerm variableTypes
>        let () =
>          logDebug (fun m ->
>              m "gettypeofargumenttermres  %a %a" pp_var name pp_infv
> -              (TypeCons (typ, tres)) )
> +              (TypeCons (typ, tres)))
>        in
>        TypeCons (typ, tres)
>  
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/typecheck/inferVariableTypes.ml src/typecheck/.formatted/inferVariableTypes.ml)
> diff --git a/src/typecheck/inferVariableTypes.ml b/src/typecheck/.formatted/inferVariableTypes.ml
> index f9827f2..6976803 100644
> --- a/src/typecheck/inferVariableTypes.ml
> +++ b/src/typecheck/.formatted/inferVariableTypes.ml
> @@ -7,7 +7,7 @@ open UnifyTypes
>  let rec newTVar nextFreeType typ =
>    match typ with
>    | TypeVar _ ->
> -      nextFreeType := !nextFreeType + 1 ;
> +      nextFreeType := !nextFreeType + 1;
>        TypeVar ("Autogen", !nextFreeType - 1)
>    | IntTyp -> IntTyp
>    | TypeCons (name, args) ->
> @@ -40,7 +40,7 @@ let rec getTypesOfVariablesFunctorBody name args constructorToType nextFreeType
>          let typ = newTVar nextFreeType (List.nth_exn cases counter) in
>          let () =
>            Hashtbl.update result var ~f:(fun prev ->
> -              match prev with Some e -> typ :: e | None -> [typ] )
> +              match prev with Some e -> typ :: e | None -> [ typ ])
>          in
>          iterArgs ags (counter + 1)
>    in
> @@ -66,7 +66,7 @@ let getTypesOfVariablesAtom predTypes constructorToType result nextFreeType
>          let typ = newTVar nextFreeType expectedTyp in
>          let () =
>            Hashtbl.update result var ~f:(fun prev ->
> -              match prev with Some e -> typ :: e | None -> [typ] )
> +              match prev with Some e -> typ :: e | None -> [ typ ])
>          in
>          iterArgs ags (counter + 1)
>    in
> @@ -76,7 +76,7 @@ let rec genMapping targs expectedargs result =
>    match (targs, expectedargs) with
>    | [], [] -> ()
>    | x :: xs, y :: ys ->
> -      Hashtbl.add_exn result ~key:x ~data:y ;
> +      Hashtbl.add_exn result ~key:x ~data:y;
>        genMapping xs ys result
>    | _, _ -> raise Oops
>  
> @@ -93,37 +93,37 @@ let rec instantiateTDR mapping (TypeDefRight (name, args)) =
>  let rec getTypesOfVariablesFromExpectedType typeDefs expectedType result term =
>    match term with
>    | TInt _ -> (
> -    match expectedType with
> -    | IntTyp -> ()
> -    | _ -> raise (Err "Type mismatch saw int") )
> +      match expectedType with
> +      | IntTyp -> ()
> +      | _ -> raise (Err "Type mismatch saw int") )
>    | TFun (structName, args) -> (
> -    match expectedType with
> -    | TypeCons (typeName, expectedargs) ->
> -        let targs, cases = Hashtbl.find_exn typeDefs typeName in
> -        let subst = Hashtbl.create strKeyImp in
> -        let () = genMapping targs expectedargs subst in
> -        let () = logDebug (fun m -> m "lookup %a" pp_var structName) in
> -        let thisCase =
> -          List.find_exn cases ~f:(fun (TypeDefRight (defname, _)) ->
> -              defname = structName )
> -        in
> -        let (TypeDefRight (n, rcases)) = instantiateTDR subst thisCase in
> -        List.iter2_exn
> -          ~f:(fun a b ->
> -            getTypesOfVariablesFromExpectedType typeDefs a result b )
> -          rcases args
> -    | _ ->
> -        raise
> -          (Err
> -             ( "Type mismatch expected type "
> -             ^ show_typeins pp_var expectedType
> -             ^ " saw struct " ^ structName )) )
> +      match expectedType with
> +      | TypeCons (typeName, expectedargs) ->
> +          let targs, cases = Hashtbl.find_exn typeDefs typeName in
> +          let subst = Hashtbl.create strKeyImp in
> +          let () = genMapping targs expectedargs subst in
> +          let () = logDebug (fun m -> m "lookup %a" pp_var structName) in
> +          let thisCase =
> +            List.find_exn cases ~f:(fun (TypeDefRight (defname, _)) ->
> +                defname = structName)
> +          in
> +          let (TypeDefRight (n, rcases)) = instantiateTDR subst thisCase in
> +          List.iter2_exn
> +            ~f:(fun a b ->
> +              getTypesOfVariablesFromExpectedType typeDefs a result b)
> +            rcases args
> +      | _ ->
> +          raise
> +            (Err
> +               ( "Type mismatch expected type "
> +               ^ show_typeins pp_var expectedType
> +               ^ " saw struct " ^ structName )) )
>    | TVar var ->
>        let () = logDebug (fun m -> m "Add type of var %a" pp_var var) in
>        let typ = argTVar expectedType in
>        let () =
>          Hashtbl.update result var ~f:(fun prev ->
> -            match prev with Some e -> typ :: e | None -> [typ] )
> +            match prev with Some e -> typ :: e | None -> [ typ ])
>        in
>        ()
>  
> @@ -136,7 +136,7 @@ let getTypesOfVariablesClauseHead
>      | [] -> ()
>      | term :: ys ->
>          let expectedType = List.nth_exn argType counter in
> -        getTypesOfVariablesFromExpectedType typeDefs expectedType result term ;
> +        getTypesOfVariablesFromExpectedType typeDefs expectedType result term;
>          iterArgs ys (counter + 1)
>    in
>    iterArgs args 0
> @@ -144,20 +144,20 @@ let getTypesOfVariablesClauseHead
>  let rec getTypesFromMathExpr result mexpr =
>    match mexpr with
>    | Plus (a, b) ->
> -      getTypesFromMathExpr result a ;
> +      getTypesFromMathExpr result a;
>        getTypesFromMathExpr result b
>    | Subtract (a, b) ->
> -      getTypesFromMathExpr result a ;
> +      getTypesFromMathExpr result a;
>        getTypesFromMathExpr result b
>    | Base (Var var) ->
>        Hashtbl.update result var ~f:(fun prev ->
> -          match prev with Some e -> IntTyp :: e | None -> [IntTyp] )
> +          match prev with Some e -> IntTyp :: e | None -> [ IntTyp ])
>    | Base (Int _) -> ()
>  
>  let getTypesFromIs result (IsExpr (var, mathExpr)) =
>    let () =
>      Hashtbl.update result var ~f:(fun prev ->
> -        match prev with Some e -> IntTyp :: e | None -> [IntTyp] )
> +        match prev with Some e -> IntTyp :: e | None -> [ IntTyp ])
>    in
>    getTypesFromMathExpr result mathExpr
>  
> @@ -196,14 +196,14 @@ let getTypesOfVariablesQuery query predTypes consToTyp =
>    let () =
>      Hashtbl.iteri
>        ~f:(fun ~key:k ~data:_ ->
> -        Hashtbl.add_exn result ~key:k ~data:(getMGUVariableType varToUses k) )
> +        Hashtbl.add_exn result ~key:k ~data:(getMGUVariableType varToUses k))
>        varToUses
>    in
>    let () = logDebug (fun m -> m "Variable types map is ") in
>    let () =
>      Hashtbl.iteri
>        ~f:(fun ~key:k ~data:v ->
> -        logDebug (fun m -> m "%a, %a" pp_var k pp_myrhs v) )
> +        logDebug (fun m -> m "%a, %a" pp_var k pp_myrhs v))
>        result
>    in
>    result
> @@ -237,7 +237,7 @@ let getTypesOfVariables (Clause (head, body)) predTypes typeDefs consToTyp =
>    let () =
>      Hashtbl.iteri
>        ~f:(fun ~key:k ~data:v ->
> -        logDebug (fun m -> m "%a, %a" pp_var k pp_myrhs v) )
> +        logDebug (fun m -> m "%a, %a" pp_var k pp_myrhs v))
>        result
>    in
>    let () = logDebug (fun m -> m "") in
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/typecheck/test/typecheckTest.ml) > _build/default/src/typecheck/test/.formatted/typecheckTest.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/typecheck/test/typecheckTest.ml src/typecheck/test/.formatted/typecheckTest.ml)
> diff --git a/src/typecheck/test/typecheckTest.ml b/src/typecheck/test/.formatted/typecheckTest.ml
> index 002ed6a..f0738f0 100644
> --- a/src/typecheck/test/typecheckTest.ml
> +++ b/src/typecheck/test/.formatted/typecheckTest.ml
> @@ -36,6 +36,6 @@ let test1 () =
>    let res = typeCheck true prog in
>    assert_equal res ()
>  
> -let suite = "Code gen tests" >::: ["test1" >:: test1]
> +let suite = "Code gen tests" >::: [ "test1" >:: test1 ]
>  
>  let _ = run_test_tt_main suite
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/utils/flattenInstrForPrint.ml) > _build/default/src/utils/.formatted/flattenInstrForPrint.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/lexer_parser/parser.ml) > _build/default/src/lexer_parser/.formatted/parser.ml
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/utils/logging.ml) > _build/default/src/utils/.formatted/logging.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/lexer_parser/parser.ml src/lexer_parser/.formatted/parser.ml)
> diff --git a/src/lexer_parser/parser.ml b/src/lexer_parser/.formatted/parser.ml
> index 817c77e..61ab40d 100644
> --- a/src/lexer_parser/parser.ml
> +++ b/src/lexer_parser/.formatted/parser.ml
> @@ -27,11 +27,12 @@ include MenhirBasics
>  
>  let _eRR = MenhirBasics.Error
>  
> -type _menhir_env =
> -  { _menhir_lexer: Lexing.lexbuf -> token
> -  ; _menhir_lexbuf: Lexing.lexbuf
> -  ; _menhir_token: token
> -  ; mutable _menhir_error: bool }
> +type _menhir_env = {
> +  _menhir_lexer : Lexing.lexbuf -> token;
> +  _menhir_lexbuf : Lexing.lexbuf;
> +  _menhir_token : token;
> +  mutable _menhir_error : bool;
> +}
>  
>  and _menhir_state =
>    | MenhirState82
> @@ -75,11 +76,11 @@ let rec _menhir_goto_new_type :
>      : 'freshtv344 )
>  
>  and _menhir_goto_typedef_list :
> -       _menhir_env
> -    -> 'ttv_tail
> -    -> _menhir_state
> -    -> 'tv_typedef_list
> -    -> 'ttv_return =
> +    _menhir_env ->
> +    'ttv_tail ->
> +    _menhir_state ->
> +    'tv_typedef_list ->
> +    'ttv_return =
>   fun _menhir_env _menhir_stack _menhir_s _v ->
>    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
>    match _menhir_s with
> @@ -98,9 +99,9 @@ and _menhir_goto_typedef_list :
>                  * 'tv_typedef_list) =
>            Obj.magic _menhir_stack
>          in
> -        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_typedef_list_elem))
> -              , _
> -              , (_3 : 'tv_typedef_list) ) =
> +        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_typedef_list_elem)),
> +                _,
> +                (_3 : 'tv_typedef_list) ) =
>              _menhir_stack
>            in
>            let _2 = () in
> @@ -116,7 +117,7 @@ and _menhir_goto_typedef_list :
>                * 'tv_typedef_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | FSTOP ->
> @@ -135,9 +136,9 @@ and _menhir_goto_typedef_list :
>                        * 'tv_typedef_list) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( (((_menhir_stack, _menhir_s), (_2 : string)), _)
> -                    , _
> -                    , (_4 : 'tv_typedef_list) ) =
> +              ( let ( (((_menhir_stack, _menhir_s), (_2 : string)), _),
> +                      _,
> +                      (_4 : 'tv_typedef_list) ) =
>                    _menhir_stack
>                  in
>                  let _5 = () in
> @@ -148,8 +149,8 @@ and _menhir_goto_typedef_list :
>                  : 'freshtv326 )
>                : 'freshtv328 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ((('freshtv329 * _menhir_state) * string) * _menhir_state)
> @@ -171,7 +172,7 @@ and _menhir_goto_typedef_list :
>                * 'tv_typedef_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | FSTOP ->
> @@ -194,11 +195,11 @@ and _menhir_goto_typedef_list :
>                        * 'tv_typedef_list) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( ( ((_menhir_stack, _menhir_s), (_2 : string))
> -                      , _
> -                      , (_3 : 'tv_var_list) )
> -                    , _
> -                    , (_5 : 'tv_typedef_list) ) =
> +              ( let ( ( ((_menhir_stack, _menhir_s), (_2 : string)),
> +                        _,
> +                        (_3 : 'tv_var_list) ),
> +                      _,
> +                      (_5 : 'tv_typedef_list) ) =
>                    _menhir_stack
>                  in
>                  let _6 = () in
> @@ -209,8 +210,8 @@ and _menhir_goto_typedef_list :
>                  : 'freshtv334 )
>                : 'freshtv336 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ( (('freshtv337 * _menhir_state) * string)
> @@ -239,7 +240,7 @@ and _menhir_goto_arith :
>                * 'tv_arith) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | MINUS ->
> @@ -260,8 +261,8 @@ and _menhir_goto_arith :
>                    _menhir_run32 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState40 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState40
>                : 'freshtv298 )
> @@ -283,8 +284,8 @@ and _menhir_goto_arith :
>                    _menhir_run32 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState38 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState38
>                : 'freshtv300 )
> @@ -324,8 +325,8 @@ and _menhir_goto_arith :
>                  : 'freshtv306 )
>                : 'freshtv308 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ('freshtv309 * _menhir_state * string)
> @@ -395,7 +396,7 @@ and _menhir_goto_program :
>    let (_menhir_stack : 'freshtv295 * _menhir_state * 'tv_program) =
>      Obj.magic _menhir_stack
>    in
> -  ( assert (not _menhir_env._menhir_error) ;
> +  ( assert (not _menhir_env._menhir_error);
>      let _tok = _menhir_env._menhir_token in
>      match _tok with
>      | END ->
> @@ -431,8 +432,8 @@ and _menhir_goto_program :
>              : 'freshtv290 )
>            : 'freshtv292 )
>      | _ ->
> -        assert (not _menhir_env._menhir_error) ;
> -        _menhir_env._menhir_error <- true ;
> +        assert (not _menhir_env._menhir_error);
> +        _menhir_env._menhir_error <- true;
>          let (_menhir_env : _menhir_env) = _menhir_env in
>          let (_menhir_stack : 'freshtv293 * _menhir_state * 'tv_program) =
>            Obj.magic _menhir_stack
> @@ -443,11 +444,11 @@ and _menhir_goto_program :
>      : 'freshtv296 )
>  
>  and _menhir_goto_typedef_body_list :
> -       _menhir_env
> -    -> 'ttv_tail
> -    -> _menhir_state
> -    -> 'tv_typedef_body_list
> -    -> 'ttv_return =
> +    _menhir_env ->
> +    'ttv_tail ->
> +    _menhir_state ->
> +    'tv_typedef_body_list ->
> +    'ttv_return =
>   fun _menhir_env _menhir_stack _menhir_s _v ->
>    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
>    match _menhir_s with
> @@ -459,7 +460,7 @@ and _menhir_goto_typedef_body_list :
>                * 'tv_typedef_body_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | RBRAC ->
> @@ -478,9 +479,9 @@ and _menhir_goto_typedef_body_list :
>                        * 'tv_typedef_body_list) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( (_menhir_stack, _menhir_s, (_1 : string))
> -                    , _
> -                    , (_3 : 'tv_typedef_body_list) ) =
> +              ( let ( (_menhir_stack, _menhir_s, (_1 : string)),
> +                      _,
> +                      (_3 : 'tv_typedef_body_list) ) =
>                    _menhir_stack
>                  in
>                  let _4 = () in
> @@ -491,8 +492,8 @@ and _menhir_goto_typedef_body_list :
>                  : 'freshtv252 )
>                : 'freshtv254 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ('freshtv255 * _menhir_state * string)
> @@ -519,9 +520,9 @@ and _menhir_goto_typedef_body_list :
>                  * 'tv_typedef_body_list) =
>            Obj.magic _menhir_stack
>          in
> -        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_typedef_body))
> -              , _
> -              , (_3 : 'tv_typedef_body_list) ) =
> +        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_typedef_body)),
> +                _,
> +                (_3 : 'tv_typedef_body_list) ) =
>              _menhir_stack
>            in
>            let _2 = () in
> @@ -537,7 +538,7 @@ and _menhir_goto_typedef_body_list :
>                * 'tv_typedef_body_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | RBRAC ->
> @@ -556,9 +557,9 @@ and _menhir_goto_typedef_body_list :
>                        * 'tv_typedef_body_list) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( (_menhir_stack, _menhir_s, (_1 : string))
> -                    , _
> -                    , (_3 : 'tv_typedef_body_list) ) =
> +              ( let ( (_menhir_stack, _menhir_s, (_1 : string)),
> +                      _,
> +                      (_3 : 'tv_typedef_body_list) ) =
>                    _menhir_stack
>                  in
>                  let _4 = () in
> @@ -569,8 +570,8 @@ and _menhir_goto_typedef_body_list :
>                  : 'freshtv264 )
>                : 'freshtv266 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ('freshtv267 * _menhir_state * string)
> @@ -590,7 +591,7 @@ and _menhir_goto_typedef_body_list :
>                * 'tv_typedef_body_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | RBRAC ->
> @@ -620,9 +621,9 @@ and _menhir_goto_typedef_body_list :
>                              * 'tv_typedef_body_list) =
>                        Obj.magic _menhir_stack
>                      in
> -                    ( let ( ((_menhir_stack, _menhir_s), (_2 : string))
> -                          , _
> -                          , (_4 : 'tv_typedef_body_list) ) =
> +                    ( let ( ((_menhir_stack, _menhir_s), (_2 : string)),
> +                            _,
> +                            (_4 : 'tv_typedef_body_list) ) =
>                          _menhir_stack
>                        in
>                        let _6 = () in
> @@ -635,8 +636,8 @@ and _menhir_goto_typedef_body_list :
>                        : 'freshtv272 )
>                      : 'freshtv274 )
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    let (_menhir_env : _menhir_env) = _menhir_env in
>                    let (_menhir_stack
>                          : (('freshtv275 * _menhir_state) * string)
> @@ -650,8 +651,8 @@ and _menhir_goto_typedef_body_list :
>                      : 'freshtv276 )
>                : 'freshtv278 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : (('freshtv279 * _menhir_state) * string)
> @@ -685,9 +686,9 @@ and _menhir_goto_sentence :
>                  * 'tv_sentence) =
>            Obj.magic _menhir_stack
>          in
> -        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_sentence_item))
> -              , _
> -              , (_2 : 'tv_sentence) ) =
> +        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_sentence_item)),
> +                _,
> +                (_2 : 'tv_sentence) ) =
>              _menhir_stack
>            in
>            let _v : 'tv_sentence = addClause _2 _1 in
> @@ -699,7 +700,7 @@ and _menhir_goto_sentence :
>        let (_menhir_stack : 'freshtv249 * _menhir_state * 'tv_sentence) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | QUES ->
> @@ -723,8 +724,8 @@ and _menhir_goto_sentence :
>                    _menhir_run30 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState82 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState82
>                : 'freshtv244 )
> @@ -740,8 +741,8 @@ and _menhir_goto_sentence :
>                _menhir_goto_program _menhir_env _menhir_stack _menhir_s _v
>                : 'freshtv246 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack : 'freshtv247 * _menhir_state * 'tv_sentence) =
>                Obj.magic _menhir_stack
> @@ -765,7 +766,7 @@ and _menhir_goto_term_list :
>                * 'tv_term_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | RBRAC ->
> @@ -784,9 +785,9 @@ and _menhir_goto_term_list :
>                        * 'tv_term_list) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( (_menhir_stack, _menhir_s, (_1 : string))
> -                    , _
> -                    , (_3 : 'tv_term_list) ) =
> +              ( let ( (_menhir_stack, _menhir_s, (_1 : string)),
> +                      _,
> +                      (_3 : 'tv_term_list) ) =
>                    _menhir_stack
>                  in
>                  let _4 = () in
> @@ -796,8 +797,8 @@ and _menhir_goto_term_list :
>                  : 'freshtv220 )
>                : 'freshtv222 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ('freshtv223 * _menhir_state * string)
> @@ -824,9 +825,9 @@ and _menhir_goto_term_list :
>                  * 'tv_term_list) =
>            Obj.magic _menhir_stack
>          in
> -        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_term))
> -              , _
> -              , (_3 : 'tv_term_list) ) =
> +        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_term)),
> +                _,
> +                (_3 : 'tv_term_list) ) =
>              _menhir_stack
>            in
>            let _2 = () in
> @@ -842,7 +843,7 @@ and _menhir_goto_term_list :
>                * 'tv_term_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | RBRAC ->
> @@ -861,9 +862,9 @@ and _menhir_goto_term_list :
>                        * 'tv_term_list) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( (_menhir_stack, _menhir_s, (_1 : string))
> -                    , _
> -                    , (_3 : 'tv_term_list) ) =
> +              ( let ( (_menhir_stack, _menhir_s, (_1 : string)),
> +                      _,
> +                      (_3 : 'tv_term_list) ) =
>                    _menhir_stack
>                  in
>                  let _4 = () in
> @@ -873,8 +874,8 @@ and _menhir_goto_term_list :
>                  : 'freshtv232 )
>                : 'freshtv234 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ('freshtv235 * _menhir_state * string)
> @@ -925,7 +926,7 @@ and _menhir_goto_var_list :
>                * 'tv_var_list) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | EQUALS ->
> @@ -943,14 +944,14 @@ and _menhir_goto_var_list :
>                    _menhir_run7 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState26 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState26
>                : 'freshtv214 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : (('freshtv215 * _menhir_state) * string)
> @@ -965,18 +966,18 @@ and _menhir_goto_var_list :
>    | _ -> _menhir_fail ()
>  
>  and _menhir_goto_typedef_list_elem :
> -       _menhir_env
> -    -> 'ttv_tail
> -    -> _menhir_state
> -    -> 'tv_typedef_list_elem
> -    -> 'ttv_return =
> +    _menhir_env ->
> +    'ttv_tail ->
> +    _menhir_state ->
> +    'tv_typedef_list_elem ->
> +    'ttv_return =
>   fun _menhir_env _menhir_stack _menhir_s _v ->
>    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
>    let (_menhir_env : _menhir_env) = _menhir_env in
>    let (_menhir_stack : 'freshtv207 * _menhir_state * 'tv_typedef_list_elem) =
>      Obj.magic _menhir_stack
>    in
> -  ( assert (not _menhir_env._menhir_error) ;
> +  ( assert (not _menhir_env._menhir_error);
>      let _tok = _menhir_env._menhir_token in
>      match _tok with
>      | COMMA ->
> @@ -992,8 +993,8 @@ and _menhir_goto_typedef_list_elem :
>                _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState21
>                  _v
>            | _ ->
> -              assert (not _menhir_env._menhir_error) ;
> -              _menhir_env._menhir_error <- true ;
> +              assert (not _menhir_env._menhir_error);
> +              _menhir_env._menhir_error <- true;
>                _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                  MenhirState21
>            : 'freshtv202 )
> @@ -1006,12 +1007,12 @@ and _menhir_goto_typedef_list_elem :
>          ( let _menhir_stack, _menhir_s, (_1 : 'tv_typedef_list_elem) =
>              _menhir_stack
>            in
> -          let _v : 'tv_typedef_list = [_1] in
> +          let _v : 'tv_typedef_list = [ _1 ] in
>            _menhir_goto_typedef_list _menhir_env _menhir_stack _menhir_s _v
>            : 'freshtv204 )
>      | _ ->
> -        assert (not _menhir_env._menhir_error) ;
> -        _menhir_env._menhir_error <- true ;
> +        assert (not _menhir_env._menhir_error);
> +        _menhir_env._menhir_error <- true;
>          let (_menhir_env : _menhir_env) = _menhir_env in
>          let (_menhir_stack
>                : 'freshtv205 * _menhir_state * 'tv_typedef_list_elem) =
> @@ -1060,9 +1061,9 @@ and _menhir_goto_clause_body :
>                  * 'tv_clause_body) =
>            Obj.magic _menhir_stack
>          in
> -        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_clause_body_one))
> -              , _
> -              , (_3 : 'tv_clause_body) ) =
> +        ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_clause_body_one)),
> +                _,
> +                (_3 : 'tv_clause_body) ) =
>              _menhir_stack
>            in
>            let _2 = () in
> @@ -1099,7 +1100,7 @@ and _menhir_goto_clause_body :
>                    let (_menhir_stack : 'freshtv175 * _menhir_state) =
>                      Obj.magic _menhir_stack
>                    in
> -                  let _ : _menhir_state = _menhir_s in
> +                  let (_ : _menhir_state) = _menhir_s in
>                    let ((_2 : 'tv_resolvant) : 'tv_resolvant) = _v in
>                    ( let _menhir_stack, _menhir_s = _menhir_stack in
>                      let _1 = () in
> @@ -1120,7 +1121,7 @@ and _menhir_goto_clause_body :
>                          : 'freshtv179 * _menhir_state * 'tv_sentence) =
>                      Obj.magic _menhir_stack
>                    in
> -                  let _ : _menhir_state = _menhir_s in
> +                  let (_ : _menhir_state) = _menhir_s in
>                    let ((_3 : 'tv_resolvant) : 'tv_resolvant) = _v in
>                    ( let _menhir_stack, _menhir_s, (_1 : 'tv_sentence) =
>                        _menhir_stack
> @@ -1142,7 +1143,7 @@ and _menhir_goto_clause_body :
>                * 'tv_clause_body) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | FSTOP ->
> @@ -1161,9 +1162,9 @@ and _menhir_goto_clause_body :
>                        * 'tv_clause_body) =
>                  Obj.magic _menhir_stack
>                in
> -              ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_atom))
> -                    , _
> -                    , (_3 : 'tv_clause_body) ) =
> +              ( let ( (_menhir_stack, _menhir_s, (_1 : 'tv_atom)),
> +                      _,
> +                      (_3 : 'tv_clause_body) ) =
>                    _menhir_stack
>                  in
>                  let _4 = () in
> @@ -1173,8 +1174,8 @@ and _menhir_goto_clause_body :
>                  : 'freshtv190 )
>                : 'freshtv192 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack
>                    : ('freshtv193 * _menhir_state * 'tv_atom)
> @@ -1189,18 +1190,18 @@ and _menhir_goto_clause_body :
>    | _ -> _menhir_fail ()
>  
>  and _menhir_goto_typedef_body :
> -       _menhir_env
> -    -> 'ttv_tail
> -    -> _menhir_state
> -    -> 'tv_typedef_body
> -    -> 'ttv_return =
> +    _menhir_env ->
> +    'ttv_tail ->
> +    _menhir_state ->
> +    'tv_typedef_body ->
> +    'ttv_return =
>   fun _menhir_env _menhir_stack _menhir_s _v ->
>    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
>    let (_menhir_env : _menhir_env) = _menhir_env in
>    let (_menhir_stack : 'freshtv169 * _menhir_state * 'tv_typedef_body) =
>      Obj.magic _menhir_stack
>    in
> -  ( assert (not _menhir_env._menhir_error) ;
> +  ( assert (not _menhir_env._menhir_error);
>      let _tok = _menhir_env._menhir_token in
>      match _tok with
>      | COMMA ->
> @@ -1220,8 +1221,8 @@ and _menhir_goto_typedef_body :
>                _menhir_run9 _menhir_env (Obj.magic _menhir_stack) MenhirState16
>                  _v
>            | _ ->
> -              assert (not _menhir_env._menhir_error) ;
> -              _menhir_env._menhir_error <- true ;
> +              assert (not _menhir_env._menhir_error);
> +              _menhir_env._menhir_error <- true;
>                _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                  MenhirState16
>            : 'freshtv164 )
> @@ -1233,12 +1234,12 @@ and _menhir_goto_typedef_body :
>          ( let _menhir_stack, _menhir_s, (_1 : 'tv_typedef_body) =
>              _menhir_stack
>            in
> -          let _v : 'tv_typedef_body_list = [_1] in
> +          let _v : 'tv_typedef_body_list = [ _1 ] in
>            _menhir_goto_typedef_body_list _menhir_env _menhir_stack _menhir_s _v
>            : 'freshtv166 )
>      | _ ->
> -        assert (not _menhir_env._menhir_error) ;
> -        _menhir_env._menhir_error <- true ;
> +        assert (not _menhir_env._menhir_error);
> +        _menhir_env._menhir_error <- true;
>          let (_menhir_env : _menhir_env) = _menhir_env in
>          let (_menhir_stack : 'freshtv167 * _menhir_state * 'tv_typedef_body) =
>            Obj.magic _menhir_stack
> @@ -1249,18 +1250,18 @@ and _menhir_goto_typedef_body :
>      : 'freshtv170 )
>  
>  and _menhir_goto_sentence_item :
> -       _menhir_env
> -    -> 'ttv_tail
> -    -> _menhir_state
> -    -> 'tv_sentence_item
> -    -> 'ttv_return =
> +    _menhir_env ->
> +    'ttv_tail ->
> +    _menhir_state ->
> +    'tv_sentence_item ->
> +    'ttv_return =
>   fun _menhir_env _menhir_stack _menhir_s _v ->
>    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
>    let (_menhir_env : _menhir_env) = _menhir_env in
>    let (_menhir_stack : 'freshtv161 * _menhir_state * 'tv_sentence_item) =
>      Obj.magic _menhir_stack
>    in
> -  ( assert (not _menhir_env._menhir_error) ;
> +  ( assert (not _menhir_env._menhir_error);
>      let _tok = _menhir_env._menhir_token in
>      match _tok with
>      | NAME _v ->
> @@ -1276,19 +1277,19 @@ and _menhir_goto_sentence_item :
>          ( let _menhir_stack, _menhir_s, (_1 : 'tv_sentence_item) =
>              _menhir_stack
>            in
> -          let _v : 'tv_sentence = Sentence [_1] in
> +          let _v : 'tv_sentence = Sentence [ _1 ] in
>            _menhir_goto_sentence _menhir_env _menhir_stack _menhir_s _v
>            : 'freshtv160 )
>      | _ ->
> -        assert (not _menhir_env._menhir_error) ;
> -        _menhir_env._menhir_error <- true ;
> +        assert (not _menhir_env._menhir_error);
> +        _menhir_env._menhir_error <- true;
>          _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState71
>      : 'freshtv162 )
>  
>  and _menhir_fail : unit -> 'a =
>   fun () ->
>    Printf.fprintf Pervasives.stderr
> -    "Internal failure -- please contact the parser generator's developers.\n%!" ;
> +    "Internal failure -- please contact the parser generator's developers.\n%!";
>    assert false
>  
>  and _menhir_goto_clause :
> @@ -1315,7 +1316,7 @@ and _menhir_goto_term :
>    let (_menhir_stack : 'freshtv153 * _menhir_state * 'tv_term) =
>      Obj.magic _menhir_stack
>    in
> -  ( assert (not _menhir_env._menhir_error) ;
> +  ( assert (not _menhir_env._menhir_error);
>      let _tok = _menhir_env._menhir_token in
>      match _tok with
>      | COMMA ->
> @@ -1336,8 +1337,8 @@ and _menhir_goto_term :
>                _menhir_run44 _menhir_env (Obj.magic _menhir_stack) MenhirState51
>                  _v
>            | _ ->
> -              assert (not _menhir_env._menhir_error) ;
> -              _menhir_env._menhir_error <- true ;
> +              assert (not _menhir_env._menhir_error);
> +              _menhir_env._menhir_error <- true;
>                _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                  MenhirState51
>            : 'freshtv148 )
> @@ -1347,12 +1348,12 @@ and _menhir_goto_term :
>            Obj.magic _menhir_stack
>          in
>          ( let _menhir_stack, _menhir_s, (_1 : 'tv_term) = _menhir_stack in
> -          let _v : 'tv_term_list = [_1] in
> +          let _v : 'tv_term_list = [ _1 ] in
>            _menhir_goto_term_list _menhir_env _menhir_stack _menhir_s _v
>            : 'freshtv150 )
>      | _ ->
> -        assert (not _menhir_env._menhir_error) ;
> -        _menhir_env._menhir_error <- true ;
> +        assert (not _menhir_env._menhir_error);
> +        _menhir_env._menhir_error <- true;
>          let (_menhir_env : _menhir_env) = _menhir_env in
>          let (_menhir_stack : 'freshtv151 * _menhir_state * 'tv_term) =
>            Obj.magic _menhir_stack
> @@ -1380,8 +1381,8 @@ and _menhir_run3 :
>          | VAR _v ->
>              _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState4 _v
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                MenhirState4
>          : 'freshtv142 )
> @@ -1391,12 +1392,12 @@ and _menhir_run3 :
>          Obj.magic _menhir_stack
>        in
>        ( let _menhir_stack, _menhir_s, (_1 : string) = _menhir_stack in
> -        let _v : 'tv_var_list = [_1] in
> +        let _v : 'tv_var_list = [ _1 ] in
>          _menhir_goto_var_list _menhir_env _menhir_stack _menhir_s _v
>          : 'freshtv144 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv145 * _menhir_state * string) =
>          Obj.magic _menhir_stack
> @@ -1427,8 +1428,8 @@ and _menhir_run7 :
>          | VAR _v ->
>              _menhir_run9 _menhir_env (Obj.magic _menhir_stack) MenhirState8 _v
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                MenhirState8
>          : 'freshtv136 )
> @@ -1442,8 +1443,8 @@ and _menhir_run7 :
>          _menhir_goto_typedef_list_elem _menhir_env _menhir_stack _menhir_s _v
>          : 'freshtv138 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv139 * _menhir_state * string) =
>          Obj.magic _menhir_stack
> @@ -1489,8 +1490,8 @@ and _menhir_run33 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
>            : 'freshtv128 )
>          : 'freshtv130 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv131 * _menhir_state) =
>          Obj.magic _menhir_stack
> @@ -1512,18 +1513,18 @@ and _menhir_run35 :
>      : 'freshtv126 )
>  
>  and _menhir_goto_clause_body_one :
> -       _menhir_env
> -    -> 'ttv_tail
> -    -> _menhir_state
> -    -> 'tv_clause_body_one
> -    -> 'ttv_return =
> +    _menhir_env ->
> +    'ttv_tail ->
> +    _menhir_state ->
> +    'tv_clause_body_one ->
> +    'ttv_return =
>   fun _menhir_env _menhir_stack _menhir_s _v ->
>    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
>    let (_menhir_env : _menhir_env) = _menhir_env in
>    let (_menhir_stack : 'freshtv123 * _menhir_state * 'tv_clause_body_one) =
>      Obj.magic _menhir_stack
>    in
> -  ( assert (not _menhir_env._menhir_error) ;
> +  ( assert (not _menhir_env._menhir_error);
>      let _tok = _menhir_env._menhir_token in
>      match _tok with
>      | COMMA ->
> @@ -1546,8 +1547,8 @@ and _menhir_goto_clause_body_one :
>                _menhir_run30 _menhir_env (Obj.magic _menhir_stack) MenhirState60
>                  _v
>            | _ ->
> -              assert (not _menhir_env._menhir_error) ;
> -              _menhir_env._menhir_error <- true ;
> +              assert (not _menhir_env._menhir_error);
> +              _menhir_env._menhir_error <- true;
>                _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                  MenhirState60
>            : 'freshtv118 )
> @@ -1560,12 +1561,12 @@ and _menhir_goto_clause_body_one :
>          ( let _menhir_stack, _menhir_s, (_1 : 'tv_clause_body_one) =
>              _menhir_stack
>            in
> -          let _v : 'tv_clause_body = [_1] in
> +          let _v : 'tv_clause_body = [ _1 ] in
>            _menhir_goto_clause_body _menhir_env _menhir_stack _menhir_s _v
>            : 'freshtv120 )
>      | _ ->
> -        assert (not _menhir_env._menhir_error) ;
> -        _menhir_env._menhir_error <- true ;
> +        assert (not _menhir_env._menhir_error);
> +        _menhir_env._menhir_error <- true;
>          let (_menhir_env : _menhir_env) = _menhir_env in
>          let (_menhir_stack : 'freshtv121 * _menhir_state * 'tv_clause_body_one)
>              =
> @@ -1611,8 +1612,8 @@ and _menhir_run10 :
>          | VAR _v ->
>              _menhir_run9 _menhir_env (Obj.magic _menhir_stack) MenhirState11 _v
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                MenhirState11
>          : 'freshtv110 )
> @@ -1626,8 +1627,8 @@ and _menhir_run10 :
>          _menhir_goto_typedef_body _menhir_env _menhir_stack _menhir_s _v
>          : 'freshtv112 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv113 * _menhir_state * string) =
>          Obj.magic _menhir_stack
> @@ -1687,7 +1688,7 @@ and _menhir_goto_atom :
>        let (_menhir_stack : 'freshtv101 * _menhir_state * 'tv_atom) =
>          Obj.magic _menhir_stack
>        in
> -      ( assert (not _menhir_env._menhir_error) ;
> +      ( assert (not _menhir_env._menhir_error);
>          let _tok = _menhir_env._menhir_token in
>          match _tok with
>          | ARR ->
> @@ -1711,8 +1712,8 @@ and _menhir_goto_atom :
>                    _menhir_run30 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState78 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState78
>                : 'freshtv94 )
> @@ -1733,8 +1734,8 @@ and _menhir_goto_atom :
>                  : 'freshtv96 )
>                : 'freshtv98 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack : 'freshtv99 * _menhir_state * 'tv_atom) =
>                Obj.magic _menhir_stack
> @@ -1782,8 +1783,8 @@ and _menhir_run45 :
>              _menhir_run44 _menhir_env (Obj.magic _menhir_stack) MenhirState46
>                _v
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                MenhirState46
>          : 'freshtv82 )
> @@ -1797,8 +1798,8 @@ and _menhir_run45 :
>          _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v
>          : 'freshtv84 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv85 * _menhir_state * string) =
>          Obj.magic _menhir_stack
> @@ -1849,22 +1850,22 @@ and _menhir_run1 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
>                    _menhir_run7 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState6 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState6
>                : 'freshtv74 )
>          | VAR _v ->
>              _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState2 _v
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                MenhirState2
>          : 'freshtv76 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv77 * _menhir_state) =
>          Obj.magic _menhir_stack
> @@ -2071,14 +2072,14 @@ and _menhir_run30 :
>              _menhir_run32 _menhir_env (Obj.magic _menhir_stack) MenhirState31
>                _v
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                MenhirState31
>          : 'freshtv28 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv29 * _menhir_state * string) =
>          Obj.magic _menhir_stack
> @@ -2160,14 +2161,14 @@ and _menhir_run64 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
>                    _menhir_run9 _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState66 _v
>                | _ ->
> -                  assert (not _menhir_env._menhir_error) ;
> -                  _menhir_env._menhir_error <- true ;
> +                  assert (not _menhir_env._menhir_error);
> +                  _menhir_env._menhir_error <- true;
>                    _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                      MenhirState66
>                : 'freshtv16 )
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              let (_menhir_env : _menhir_env) = _menhir_env in
>              let (_menhir_stack : ('freshtv17 * _menhir_state) * string) =
>                Obj.magic _menhir_stack
> @@ -2177,8 +2178,8 @@ and _menhir_run64 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
>                : 'freshtv18 )
>          : 'freshtv20 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv21 * _menhir_state) =
>          Obj.magic _menhir_stack
> @@ -2212,8 +2213,8 @@ and _menhir_run42 :
>              _menhir_run44 _menhir_env (Obj.magic _menhir_stack) MenhirState43
>                _v
>          | _ ->
> -            assert (not _menhir_env._menhir_error) ;
> -            _menhir_env._menhir_error <- true ;
> +            assert (not _menhir_env._menhir_error);
> +            _menhir_env._menhir_error <- true;
>              _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                MenhirState43
>          : 'freshtv6 )
> @@ -2227,8 +2228,8 @@ and _menhir_run42 :
>          _menhir_goto_atom _menhir_env _menhir_stack _menhir_s _v
>          : 'freshtv8 )
>    | _ ->
> -      assert (not _menhir_env._menhir_error) ;
> -      _menhir_env._menhir_error <- true ;
> +      assert (not _menhir_env._menhir_error);
> +      _menhir_env._menhir_error <- true;
>        let (_menhir_env : _menhir_env) = _menhir_env in
>        let (_menhir_stack : 'freshtv9 * _menhir_state * string) =
>          Obj.magic _menhir_stack
> @@ -2242,10 +2243,12 @@ and _menhir_discard : _menhir_env -> _menhir_env =
>    let lexer = _menhir_env._menhir_lexer in
>    let lexbuf = _menhir_env._menhir_lexbuf in
>    let _tok = lexer lexbuf in
> -  { _menhir_lexer= lexer
> -  ; _menhir_lexbuf= lexbuf
> -  ; _menhir_token= _tok
> -  ; _menhir_error= false }
> +  {
> +    _menhir_lexer = lexer;
> +    _menhir_lexbuf = lexbuf;
> +    _menhir_token = _tok;
> +    _menhir_error = false;
> +  }
>  
>  and main :
>      (Lexing.lexbuf -> token) -> Lexing.lexbuf -> string ParseTree.program =
> @@ -2254,10 +2257,12 @@ and main :
>      let (lexer : Lexing.lexbuf -> token) = lexer in
>      let (lexbuf : Lexing.lexbuf) = lexbuf in
>      ( let _tok = Obj.magic () in
> -      { _menhir_lexer= lexer
> -      ; _menhir_lexbuf= lexbuf
> -      ; _menhir_token= _tok
> -      ; _menhir_error= false }
> +      {
> +        _menhir_lexer = lexer;
> +        _menhir_lexbuf = lexbuf;
> +        _menhir_token = _tok;
> +        _menhir_error = false;
> +      }
>        : _menhir_env )
>    in
>    Obj.magic
> @@ -2293,15 +2298,15 @@ and main :
>                   _menhir_run30 _menhir_env (Obj.magic _menhir_stack)
>                     MenhirState29 _v
>               | _ ->
> -                 assert (not _menhir_env._menhir_error) ;
> -                 _menhir_env._menhir_error <- true ;
> +                 assert (not _menhir_env._menhir_error);
> +                 _menhir_env._menhir_error <- true;
>                   _menhir_errorcase _menhir_env (Obj.magic _menhir_stack)
>                     MenhirState29
>               : 'freshtv2 )
>         | TYPEDEF ->
>             _menhir_run1 _menhir_env (Obj.magic _menhir_stack) MenhirState0
>         | _ ->
> -           assert (not _menhir_env._menhir_error) ;
> -           _menhir_env._menhir_error <- true ;
> +           assert (not _menhir_env._menhir_error);
> +           _menhir_env._menhir_error <- true;
>             _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState0
>         : 'freshtv4 ))
[1]
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/utils/logging.ml src/utils/.formatted/logging.ml)
> diff --git a/src/utils/logging.ml b/src/utils/.formatted/logging.ml
> index b1fc158..42340fa 100644
> --- a/src/utils/logging.ml
> +++ b/src/utils/.formatted/logging.ml
> @@ -2,8 +2,8 @@ open Logs
>  
>  let myLog =
>    let log = Logs.Src.create "logs" in
> -  Logs.set_level (Some Info) ;
> -  Logs.set_reporter (Logs_fmt.reporter ~pp_header:Fmt.nop ()) ;
> +  Logs.set_level (Some Info);
> +  Logs.set_reporter (Logs_fmt.reporter ~pp_header:Fmt.nop ());
>    log
>  
>  let logDebug msg = Logs.debug ~src:myLog msg
[1]
$ (cd _build/default && /home/phoebe/.opam/4.08.0/bin/ocamlformat --impl src/utils/utils.ml) > _build/default/src/utils/.formatted/utils.ml
$ (cd _build/default && /usr/bin/git diff --no-index --color=always -u src/utils/utils.ml src/utils/.formatted/utils.ml)
> diff --git a/src/utils/utils.ml b/src/utils/.formatted/utils.ml
> index e653a0a..c05e0b3 100644
> --- a/src/utils/utils.ml
> +++ b/src/utils/.formatted/utils.ml
> @@ -6,7 +6,10 @@ let rec foldLeft f xs r =
>  
>  let seen var soFar =
>    let lookup = Hash_set.exists soFar ~f:(fun f -> f = var) in
> -  if lookup then true else ( Hash_set.add soFar var ; false )
> +  if lookup then true
> +  else (
> +    Hash_set.add soFar var;
> +    false )
>  
>  let getStructMapInt (structMapGen : structMapGen) str =
>    let x = Hashtbl.find structMapGen.mapping str in
> @@ -14,8 +17,8 @@ let getStructMapInt (structMapGen : structMapGen) str =
>    | Some n -> n
>    | None ->
>        let next = structMapGen.nextFree in
> -      Hashtbl.add_exn structMapGen.mapping ~key:str ~data:next ;
> -      structMapGen.nextFree <- next + 1 ;
> +      Hashtbl.add_exn structMapGen.mapping ~key:str ~data:next;
> +      structMapGen.nextFree <- next + 1;
>        next
>  
>  let getStructMapFid (structMapGen : structMapGen) (name, nums) =
> @@ -24,7 +27,7 @@ let getStructMapFid (structMapGen : structMapGen) (name, nums) =
>  let reverseTbl tbl =
>    let newTable = Hashtbl.create ~size:(Hashtbl.length tbl) intImp in
>    Hashtbl.iteri tbl ~f:(fun ~key ~data:value ->
> -      Hashtbl.add_exn newTable ~key:value ~data:key ) ;
> +      Hashtbl.add_exn newTable ~key:value ~data:key);
>    newTable
>  
>  let reverseStructmap sg = reverseTbl sg.mapping
[1]
