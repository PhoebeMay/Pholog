@inproceedings{costsBenefitsAbstract,
  title={The Costs and Benefits of Abstract Interpretation-driven Prolog Optimization},
  author={Thomas W. Getzinger},
  booktitle={
Proceedings of the First International Static Analysis Symposium on Static Analysis
},
  year={1994}
}

@Book{ocamlBook,
  author =       "Anil Madhavapeddy, Jason Hickey, and Yaron Minsky",
  title =        "Real World OCaml: Functional Programming for the Masses",
  publisher =    "O'Reilly Media",
}

@misc{PUnit,
  title = "Prolog {U}nit {T}ests",
  note = "SWI-Prolog Documentation",
  author = {Jan Wielemaker},
  howpublished = {\url{http://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/plunit.html%27)}},
}

@misc{REFswi,
   title = "SWI-Prolog 6.1",
note = "Reference Manual",
 author = {Jan Wielemaker},
howpublished = {\url{www.swi-prolog.org/download/devel/doc/SWI-Prolog-6.1.5.pdf}},
}

@misc{SpaceT,
  title = "Memory profiling with {S}pacetime",
  note = "OCaml Documentation",
  howpublished = {\url{https://caml.inria.fr/pub/docs/manual-ocaml/spacetime.html}},
}

@misc{ocamlyacc,
  title = "Lexer and parser generators (ocamllex, ocamlyacc)",
  note = "OCaml Documentation",
  howpublished = {\url{https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html}},
}

@book{citeulike:14362116,
  added-at = {2017-06-29T07:13:07.000+0200},
  author = {Hickey, Jason and Madhavapeddy, Anil and Minsky, Yaron},
  biburl = {https://www.bibsonomy.org/bibtex/20c52803b6d2158b9479e6826f1694538/gdmcbain},
  citeulike-article-id = {14362116},
  citeulike-linkout-0 = {http://www.worldcat.org/isbn/144932391},
  citeulike-linkout-1 = {http://books.google.com/books?vid=ISBN144932391},
  citeulike-linkout-2 = {http://www.amazon.com/gp/search?keywords=144932391\&index=books\&linkCode=qs},
  citeulike-linkout-3 = {http://www.librarything.com/isbn/144932391},
  citeulike-linkout-4 = {http://www.worldcat.org/oclc/937869151},
  interhash = {f0869261ea111e0f3c12e0ef06e8803d},
  intrahash = {0c52803b6d2158b9479e6826f1694538},
  isbn = {144932391},
  keywords = {68-01-computer-science-instructional-exposition, 68n18-functional-programming-and-lambda-calculus, ocaml 68n15-programming-languages},
  posted-at = {2017-05-24 01:23:52},
  priority = {5},
  timestamp = {2019-02-27T00:52:46.000+0100},
  title = {{Real World OCaml}},
  url = {https://v1.realworldocaml.org/v1/en/html/parsing-with-ocamllex-and-menhir.html},
  year = 2014
}



@misc{PExec,
  title = "Execution profiling",
  note = "SWI-Prolog Documentation",
  howpublished = {\url{http://www.swi-prolog.org/pldoc/man?section=profile}},
}


@misc{OUnit,
  title = {O{U}nit},
  note = "OCaml unit testing framework",
  howpublished = {\url{hhttp://ounit.forge.ocamlcore.org/}},
}

@article{autoMode,
title = "Automatic mode inference for logic programs",
journal = "The Journal of Logic Programming",
volume = "5",
number = "3",
pages = "207 - 229",
year = "1988",
issn = "0743-1066",
doi = "https://doi.org/10.1016/0743-1066(88)90010-6",
url = "http://www.sciencedirect.com/science/article/pii/0743106688900106",
author = "Saumya K. Debray and David S. Warren"
}

@article{datalog,
title = "Datalog and Emerging Applications: An Interactive Tutorial",
year = "2011",
author = "Shan Shan Huang, Todd Jeffrey Green, and Boon Thau Loo",
journal = "SIGMOD",
pages = "1213 - 1216",
}

@article{doop,
title = "Using Datalog for fast and easy program analysis",
year = "2010",
author = "Y. Smaragdakis and M. Bravenboer",
journal = "Datalog 2.0 Workshop",
}

@misc{jvm11,
title = "The JavaÂ® Virtual Machine Specification Java SE 11 Edition",
year = "2018",
author = "Tim Lindholm, Frank Yellin, Gilad Bracha, Alex Buckley, Daniel Smith"
}

@article{logprog,
title = "The Semantics of Predicate Logic as a Programming Language",
journal = "Journal of the ACM",
year = "1976",
author = "van Emden, M. and Kowalski, R.",
volume = "23",
number = "4",
pages = "733 - 742"
}

@inproceedings{kowalski,
author = {Kowalski, Robert},
year = {1974},
month = {01},
pages = {569-574},
title = {Predicate Logic as Programming Language},
volume = {74},
journal = {IFIP Congr.}
}

@article{Kowalski1971,
abstract = {Linear resolution with selection function (SL-resolution) is a restricted form of linear resolution. The main restriction is effected by a selection function which chooses from each clause a single literal to be resolved upon in that clause. This and other restrictions are adapted to linear resolution from Loveland's model elimination. We show that SL-resolution achieves a substantial reduction in the generation of redundant and irrelevant derivations and does so without significantly increasing the complexity of simplest proofs. We base our argument for the increased efficiency of SL-resolution upon precise calculation of these quantities. A more far reaching advantage of SL-resolution is its suitability for heuristic search. In particular, classification trees, subgoals, lemmas, and/orssearch trees can all be used to increase the efficiency of finding refutations. These considerations alone suggest the superiority of SL-resolution to theorem-proving procedures constructed solely for their heuristic attraction. From comparison with other theorem-proving methods, we conjecture that best proof procedures for first order logic will be obtained by further elaboration of SL-resolution. {\textcopyright} 1971.},
author = {Kowalski, Robert and Kuehner, Donald},
doi = {10.1016/0004-3702(71)90012-9},
issn = {00043702},
journal = {Artificial Intelligence},
title = {{Linear resolution with selection function}},
year = {1971}
}


@inproceedings{Kawalski1974,
abstract = {The interpretation of predicate logic as a programming language is based upon the interpretation of implications B if A1 and ... and An as procedure declarations, where B is the procedure name and A1, {\ldots}, An is the set of procedure calls Ai constituting the procedure body. An axiomatisation of a problem domain is a program for solving problems in that domain. Individual problems are posed as theorems to be proved. Proofs are computations generated by the theorem-prover which executes the program incorporated in the axioms. Our thesis is that predicate logic is a useful and practical, high-level, non-deterministic programming language with sound theoretical foundations.},
author = {Kawalski, Robert},
booktitle = {Proceedings of the International Federation for Information Processing Congress},
title = {{Predicate logic as programming language}},
year = {1974}
}


@article{Kowalski2002,
abstract = {This firsthand recollection of those early days of logic programming traces the shared influences and inspirations that connected Edinburgh, Scotland, and Marseilles, France.},
author = {Kowalski, Robert A.},
doi = {10.1145/35043.35046},
issn = {00010782},
journal = {Communications of the ACM},
title = {{The early years of logic programming}},
year = {2002}
}


@article{mycroftTypes,
title = "A polymorphic type system for prolog",
journal = "Artificial Intelligence",
volume = "23",
number = "3",
pages = "295 - 307",
year = "1984",
issn = "0004-3702",
doi = "https://doi.org/10.1016/0004-3702(84)90017-1",
url = "http://www.sciencedirect.com/science/article/pii/0004370284900171",
author = "Alan Mycroft and Richard A. O'Keefe"
}

@article{WAM,
title = "An abstract {P}rolog instruction set",
journal = "SRI international",
year = "1983",
author = "David H. D. Warren"
}

@article{impProg,
title = "Implementation Techniques for Prolog",
journal = {Institut f\"ur Computersprachen
Technische Universit\"at Wien
},
year = "1985",
author = "Andreas Krall"
}


@phdthesis{fastProlog,
author ={Peter Lodewijk Van Roy},
title ={Can  Logic  Programming  Execute
as  Fast  as  Imperative  Programming?},
publisher ={Computer Science Division, UC Berkeley},
year ={1990}
}

@InProceedings{regFree,
author="Zhou, Neng-Fa",
editor="Dahl, V{\'e}ronica
and Niemel{\"a}, Ilkka",
title="A Register-Free Abstract Prolog Machine with Jumbo Instructions",
booktitle="Logic Programming",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="455--457",
abstract="The majority of current Prolog systems are based on the WAM, in which registers are used to pass procedure arguments and store temporary data. In this paper, we present a stack machine for Prolog, named TOAM Jr., which departs from the TOAM adopted in early versions of B-Prolog in that it employs no registers for temporary data and it offers variable-size instructions for encoding unification and procedure calls. TOAM Jr. is suitable for fast bytecode interpretation: the omission of registers facilitates instruction merging and the use of jumbo instructions results in more compact code and execution of fewer instructions than the use of fine-grained instructions. TOAM Jr. is employed in B-Prolog version 7.0. Benchmarking shows that TOAM Jr. helps significantly improve the performance: the execution speed is increased by 48{\%} on a Windows PC and 77{\%} on a Linux machine. Despite the overhead on standard Prolog programs caused by the adoption of a spaghetti stack to support event handling and constraint solving, B-Prolog version 7.0 compares favorably well with the state-of-the-art WAM-based Prolog systems.",
isbn="978-3-540-74610-2"
}
